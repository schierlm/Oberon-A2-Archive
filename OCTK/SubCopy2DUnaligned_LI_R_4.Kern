il_ps_2_0
;
;	2D subarray copy for the case when arrays are non virtualized and copy regions are not aligned to
;	nComponents (srcOrigin[1] MOD nComponents # 0) OR (dstOrigin[1] MOD nComponents # 0) OR (size[1] MOD nComponents) # 0)
; 
;	inputs: 2 (src,dst)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 (same for input and output)
;	constants: 1,  2 x 4 (LONGINT) : [srcOrigin[1],srcOrigin[0],dstOrigin[1],dstOrigin[0]];  [subSize[1],subSize[0],dstOrigin[1] DIV 4,...]
;	kernel type: PS
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[2]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, -1, -1, 0

ftoi r0.xy, vWinCoord0.xy ; convert output position in multi-component elements  to integers
mov r0.z, r0.x ; r0.z := Int(vWinCoord0.x)

; output position in single-component elements
umul r0.x, r0.x, l0.x ; x*4

; account unaligned dstOrigin[1]
ieq r4.x, r0.z, cb0[1].z ; Int(vWinCoord0.x) = dstOrigin[1] DIV 4
if_logicalnz r4.x
	umod r4.x, cb0[0].z, l0.x ; dstOrigin[1] MOD 4
	iadd r0.x, r0.x, r4.x
endif

; input position in single-component elements
umad r1.xy, cb0[0].zw, l0.yz, cb0[0].xy ; [srcOrigin[1],srcOrigin[0]] - [dstOrigin[1],dstOrigin[0]]
iadd r1.xy, r0.xy, r1.xy

umod r4.x, r1.x, l0.x ; input.x MOD 4
udiv r1.x, r1.x, l0.x ; input position in multi-component elements
itof r1.xy, r1.xy

switch r4.x
	
	case 0
		sample_resource(0)_sampler(0) r3.xyzw, r1.xy
	break
		
	case 1		
		sample_resource(0)_sampler(0) r3._yzw, r1.xy		
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.x___, r1.xy
		mov r3.xyzw, r3.yzwx
	break
	
	case 2
		sample_resource(0)_sampler(0) r3.__zw, r1.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.xy__, r1.xy		
		mov r3.xyzw, r3.zwxy
	break
	
	case 3
		sample_resource(0)_sampler(0) r3.___w, r1.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.xyz_, r1.xy
		mov r3.xyzw, r3.wxyz
	break
endswitch

; write to the output

iadd r4.x, cb0[0].z, cb0[1].x ; dstOrigin[1] + subSize[1]	
iadd r4.x, r4.x, l0.y ; dstOrigin[1] + subSize[1] - 1 ; right dst bound in single-component elements	
udiv r4.y, r4.x, l0.x ; (dstOrigin[1] + subSize[1] - 1) DIV 4 ; right dst bound in multi-component elements

ine r4.z, r0.z, cb0[1].z ; output.x # (dstOrigin[1] DIV 4) -> not the left dst bound
if_logicalnz r4.z		
	
	ine r4.z, r0.z, r4.y ; Int(vWinCoord0.x) # (dstOrigin[1] + subSize[1] - 1) DIV 4 -> not the right dst bound
	if_logicalnz r4.z
		mov o0.xyzw, r3.xyzw
	else
		
		umod r4.z, r4.x, l0.x ; (dstOrigin[1] + subSize[1] - 1) MOD 4
		
		switch r4.z
			
			case 0
				sample_resource(1)_sampler(1) r3._yzw, vWinCoord0.xy
				mov o0, r3
			break
			
			case 1
				sample_resource(1)_sampler(1) r3.__zw, vWinCoord0.xy
				mov o0, r3
			break
			
			case 2
				sample_resource(1)_sampler(1) r3.___w, vWinCoord0.xy
				mov o0, r3
			break
			
			case 3
				mov o0, r3
			break
		endswitch
		
	endif	
	
else ; the left dst bound

	ine r4.z, r0.z, r4.y ; Int(vWinCoord0.x) # (dstOrigin[1] + subSize[1] - 1) DIV 4 -> not the right dst bound
	if_logicalnz r4.z
			
		umod r4.z, cb0[0].z, l0.x ; dstOrigin[1] MOD 4
		
		switch r4.z						
		
			case 0
				mov o0, r3
			break
			
			case 1
				mov r3.0yzw, r3.0xyz
				sample_resource(1)_sampler(1) r3.x___, vWinCoord0.xy
				mov o0, r3
			break
			
			case 2
				mov r3.00zw, r3.00xy
				sample_resource(1)_sampler(1) r3.xy__, vWinCoord0.xy
				mov o0, r3
			break
			
			case 3
				mov r3.000w, r3.000x
				sample_resource(1)_sampler(1) r3.xyz_, vWinCoord0.xy
				mov o0, r3
			break
									
		endswitch				
			
	else ; very specific case when subSize[1] <= nComponents			
	
		umod r4.x, cb0[0].z, l0.x; dstOrigin[1] MOD 4		
		
		switch r4.x
			
			case 0				
				switch cb0[1].x ; subSize[1]
				
					case 1
						sample_resource(1)_sampler(1) r3._yzw, vWinCoord0.xy
						mov o0, r3
					break
					
					case 2
						sample_resource(1)_sampler(1) r3.__zw, vWinCoord0.xy
					mov o0, r3
					break
					
					case 3
						sample_resource(1)_sampler(1) r3.___w, vWinCoord0.xy
						mov o0, r3
					break
					
					case 4
						mov o0, r3
					break
										
				endswitch;
			break
			
			case 1
				switch cb0[1].x ; subSize[1]
					case 1
						mov r3.y, r3.x
						sample_resource(1)_sampler(1) r3.x_zw, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 2
						mov r3.0yz0, r3.0xy0
						sample_resource(1)_sampler(1) r3.x__w, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 3
						mov r3.0yzw, r3.0xyz
						sample_resource(1)_sampler(1) r3.x___, vWinCoord0.xy	
						mov o0, r3
					break										
				endswitch;
			break
			
			case 2
				switch cb0[1].x ; subSize[1]
					case 1
						mov r3.z, r3.x
						sample_resource(1)_sampler(1) r3.xy_w, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 2
						mov r3.00zw, r3.00xy
						sample_resource(1)_sampler(1) r3.xy__, vWinCoord0.xy
						mov o0, r3
					break										
				endswitch;
			break
			
			case 3				
				mov r3.w, r3.x
				sample_resource(1)_sampler(1) r3.xyz_, vWinCoord0.xy
				mov o0, r3
			break
		endswitch				
		
	endif

endif								

end
