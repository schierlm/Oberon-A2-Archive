<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>

<Kernels>
	
	<ILKernel name = "SubCopy2DAligned_LI_R_LR">		
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when arrays are non virtualized and copy regions are aligned to
;	nComponents (srcOrigin[1] MOD nComponents = 0) & (dstOrigin[1] MOD nComponents = 0) 
;	& (subSize[1] MOD nComponents) = 0)
;	for both input and output
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: any (but same for input and output)
;	constants: 1 (REAL) : [(srcOrigin[1]-dstOrigin[1]) DIV nComponents,srcOrigin[0]-dstOrigin[0],...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

add r0.xy, vWinCoord0.xy, cb0[0].xy	; compute position in the input
sample_resource(0)_sampler(0) r1, r0
mov o0, r1
end
]]>
	</ILKernel>
	
	<ILKernel name = "SubCopy2DUnaligned_LI_R_4">
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when arrays are non virtualized and copy regions are not aligned to
;	nComponents (srcOrigin[1] MOD nComponents # 0) OR (dstOrigin[1] MOD nComponents # 0) OR (subSize[1] MOD nComponents) # 0)
; 
;	inputs: 2 (src,dst)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 (same for input and output)
;	constants: 1,  2 x 4 (LONGINT) : [srcOrigin[1],srcOrigin[0],dstOrigin[1],dstOrigin[0]];  [subSize[1],subSize[0],dstOrigin[1] DIV 4,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[2]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, -1, -1, 0

ftoi r0.xy, vWinCoord0.xy ; convert output position in multi-component elements  to integers
mov r0.z, r0.x ; r0.z := Int(vWinCoord0.x)

; output position in single-component elements
umul r0.x, r0.x, l0.x ; x*4

; account unaligned dstOrigin[1]
ieq r4.x, r0.z, cb0[1].z ; Int(vWinCoord0.x) = dstOrigin[1] DIV 4
if_logicalnz r4.x
	umod r4.x, cb0[0].z, l0.x ; dstOrigin[1] MOD 4
	iadd r0.x, r0.x, r4.x
endif

; input position in single-component elements
umad r1.xy, cb0[0].zw, l0.yz, cb0[0].xy ; [srcOrigin[1],srcOrigin[0]] - [dstOrigin[1],dstOrigin[0]]
iadd r1.xy, r0.xy, r1.xy

umod r4.x, r1.x, l0.x ; input.x MOD 4
udiv r1.x, r1.x, l0.x ; input position in multi-component elements
itof r1.xy, r1.xy

switch r4.x
	
	case 0
		sample_resource(0)_sampler(0) r3.xyzw, r1.xy
	break
		
	case 1		
		sample_resource(0)_sampler(0) r3._yzw, r1.xy		
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.x___, r1.xy
		mov r3.xyzw, r3.yzwx
	break
	
	case 2
		sample_resource(0)_sampler(0) r3.__zw, r1.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.xy__, r1.xy		
		mov r3.xyzw, r3.zwxy
	break
	
	case 3
		sample_resource(0)_sampler(0) r3.___w, r1.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.xyz_, r1.xy
		mov r3.xyzw, r3.wxyz
	break
endswitch

; write to the output

iadd r4.x, cb0[0].z, cb0[1].x ; dstOrigin[1] + subSize[1]	
iadd r4.x, r4.x, l0.y ; dstOrigin[1] + subSize[1] - 1 ; right dst bound in single-component elements	
udiv r4.y, r4.x, l0.x ; (dstOrigin[1] + subSize[1] - 1) DIV 4 ; right dst bound in multi-component elements

ine r4.z, r0.z, cb0[1].z ; output.x # (dstOrigin[1] DIV 4) -> not the left dst bound
if_logicalnz r4.z		
	
	ine r4.z, r0.z, r4.y ; Int(vWinCoord0.x) # (dstOrigin[1] + subSize[1] - 1) DIV 4 -> not the right dst bound
	if_logicalnz r4.z
		mov o0.xyzw, r3.xyzw
	else
		
		umod r4.z, r4.x, l0.x ; (dstOrigin[1] + subSize[1] - 1) MOD 4
		
		switch r4.z
			
			case 0
				sample_resource(1)_sampler(1) r3._yzw, vWinCoord0.xy
				mov o0, r3
			break
			
			case 1
				sample_resource(1)_sampler(1) r3.__zw, vWinCoord0.xy
				mov o0, r3
			break
			
			case 2
				sample_resource(1)_sampler(1) r3.___w, vWinCoord0.xy
				mov o0, r3
			break
			
			case 3
				mov o0, r3
			break
		endswitch
		
	endif
	
else ; the left dst bound

	ine r4.z, r0.z, r4.y ; Int(vWinCoord0.x) # (dstOrigin[1] + subSize[1] - 1) DIV 4 -> not the right dst bound
	if_logicalnz r4.z
			
		umod r4.z, cb0[0].z, l0.x ; dstOrigin[1] MOD 4
		
		switch r4.z						
		
			case 0
				mov o0, r3
			break
			
			case 1
				mov r3.0yzw, r3.0xyz
				sample_resource(1)_sampler(1) r3.x___, vWinCoord0.xy
				mov o0, r3
			break
			
			case 2
				mov r3.00zw, r3.00xy
				sample_resource(1)_sampler(1) r3.xy__, vWinCoord0.xy
				mov o0, r3
			break
			
			case 3
				mov r3.000w, r3.000x
				sample_resource(1)_sampler(1) r3.xyz_, vWinCoord0.xy
				mov o0, r3
			break
									
		endswitch				
			
	else ; very specific case when subSize[1] <= nComponents			
	
		umod r4.x, cb0[0].z, l0.x; dstOrigin[1] MOD 4		
		
		switch r4.x
			
			case 0				
				switch cb0[1].x ; subSize[1]
				
					case 1
						sample_resource(1)_sampler(1) r3._yzw, vWinCoord0.xy
						mov o0, r3
					break
					
					case 2
						sample_resource(1)_sampler(1) r3.__zw, vWinCoord0.xy
					mov o0, r3
					break
					
					case 3
						sample_resource(1)_sampler(1) r3.___w, vWinCoord0.xy
						mov o0, r3
					break
					
					case 4
						mov o0, r3
					break
										
				endswitch;
			break
			
			case 1
				switch cb0[1].x ; subSize[1]
					case 1
						mov r3.y, r3.x
						sample_resource(1)_sampler(1) r3.x_zw, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 2
						mov r3.0yz0, r3.0xy0
						sample_resource(1)_sampler(1) r3.x__w, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 3
						mov r3.0yzw, r3.0xyz
						sample_resource(1)_sampler(1) r3.x___, vWinCoord0.xy	
						mov o0, r3
					break										
				endswitch;
			break
			
			case 2
				switch cb0[1].x ; subSize[1]
					case 1
						mov r3.z, r3.x
						sample_resource(1)_sampler(1) r3.xy_w, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 2
						mov r3.00zw, r3.00xy
						sample_resource(1)_sampler(1) r3.xy__, vWinCoord0.xy
						mov o0, r3
					break										
				endswitch;
			break
			
			case 3				
				mov r3.w, r3.x
				sample_resource(1)_sampler(1) r3.xyz_, vWinCoord0.xy
				mov o0, r3
			break
		endswitch				
		
	endif

endif								

end				
]]>	
	</ILKernel>
	
	<ILKernel name = "SubCopy2DNonVirtToVirt_LI_R_4">					
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when source array is not virtualized and destination is virtualized
; 
;	inputs: 1 (src)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 - for the input, 1 - for the output (virtualized)
;	constants: 1, 2x4 (LONGINT) : [srcOrigin[1]-dstOrigin[1],srcOrigin[0]-dstOrigin[0],dst.Width,dst.physWidth]; [dstOrigin[1],dstOrigin[0],dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[2]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, 0, 0, 0

; compute linear index in the output
ftoi r0.xy, vWinCoord0.xy
umad r0.x, r0.y, cb0[0].w, r0.x ; ind := y*dst.physWidth + x

; compute non-virtual position in the output
udiv r0.y, r0.x, cb0[0].z ; y := ind DIV dst.Width
umod r0.x, r0.x, cb0[0].z

ilt r1.xy, r0.xy, cb0[1].xy ; [x,y] < [dstOrigin[1],dstOrigin[0]]
inot r1.xy, r1.xy ;  ~([x,y] < [dstOrigin[1],dstOrigin[0]]) -> [x,y] >= [dstOrigin[1],dstOrigin[0]]
ilt r2.xy, r0.xy, cb0[1].zw ; [x,y] < [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
and r1.xy, r1.xy, r2.xy
ieq r2.xy, r0.xy, cb0[1].zw ; [x,y] = [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
ior r1.xy, r1.xy, r2.xy ; ([x,y] >= [dstOrigin[1],dstOrigin[0]]) & ([x,y] <= [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1])

and r1.x, r1.x, r1.y
if_logicalnz r1.x

	; compute 2D position in the input, in single-component elements
	iadd r0.xy, r0.xy, cb0[0].xy

	umod r0.z, r0.x, l0.x ; x MOD 4

	udiv r0.x, r0.x, l0.x ; input position in multi-component elements
	itof r0.xy, r0.xy ; convert [x,y] to floats

	switch r0.z
		
		case 0
			sample_resource(0)_sampler(0) o0.x, r0.xy
		break
		
		case 1
			sample_resource(0)_sampler(0) r1._y__, r0.xy
			mov o0.x, r1.y
		break
		
		case 2
			sample_resource(0)_sampler(0) r1.__z_, r0.xy
			mov o0.x, r1.z
		break
	
		case 3
			sample_resource(0)_sampler(0) r1.___w, r0.xy
			mov o0.x, r1.w
		break
	endswitch	

else
	sample_resource(1)_sampler(1) o0.x, vWinCoord0.xy	
endif

end				
]]>	
	</ILKernel>
	
	<ILKernel name = "SubCopy2DVirtToNonVirtAligned_LI_R_4">	
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when source array is virtualized, destination is not virtualized, and copy regions are aligned to
;	nComponents (dstOrigin[1] MOD nComponents = 0) & (subSize[1] MOD nComponents) = 0)
; 
;	inputs: 1 (src)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 - for the output, 1 - for the input (virtualized)
;	constants: 1 (LONGINT) : [srcOrigin[1]-dstOrigin[1],srcOrigin[0]-dstOrigin[0],src.Width,src.physWidth]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, -1, 0, 0

; compute non-virtual position in the input
ftoi r0.xy, vWinCoord0.xy
umul r0.x, r0.x, l0.x ; output position in single-component elements
iadd r0.xy, r0.xy, cb0[0].xy ; input position in single-component elements

; compute linear index in the input
umad r1.x, r0.y, cb0[0].z, r0.x ; ind := y*src.Width + x

; compute 2D virtual position in the input
udiv r1.y, r1.x, cb0[0].w ; y := ind DIV src.physWidth
umod r1.x, r1.x, cb0[0].w ; x := ind MOD src.physWidth

umad r4.x, r1.x, l0.y, cb0[0].w ; r4.x := src.physWidth - x

itof r1.xy, r1.xy

ige r4.z, r4.x, l0.x ; src.physWidth - x >= 4
if_logicalnz r4.z		
	
	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) o0.x, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) o0.y, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) o0.z, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) o0.w, r1.xy
		
else
	
	itof r5.x, cb0[0].w
	
	add r2.xy, r1.xy, r1.10
	ge r5.z, r2.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r2.0y, r2.y, r2.1 ; INC(y)
	endif
	
	add r3.xy, r2.xy, r2.10
	ge r5.z, r3.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r3.0y, r3.y, r3.1 ; INC(y)
	endif
	
	add r4.xy, r3.xy, r3.10
	ge r5.z, r4.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r4.0y, r4.y, r4.1 ; INC(y)
	endif
	
	sample_resource(0)_sampler(0) o0.x, r1.xy
	sample_resource(0)_sampler(0) o0.y, r2.xy
	sample_resource(0)_sampler(0) o0.z, r3.xy
	sample_resource(0)_sampler(0) o0.w, r4.xy
		
endif

end
]]>	
	</ILKernel>
	
	<ILKernel name = "SubCopy2DSplit8ToNonVirtAligned_LI_R_LR">		
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when input array is splitted into 8 parts, output array is not virtualized
;	and copy regions are aligned to nComponents (srcOrigin[1] MOD nComponents = 0) 
;	& (dstOrigin[1] MOD nComponents = 0) & (subSize[1] MOD nComponents) = 0) for both input and output
; 
;	inputs: 8
;	outputs: 1
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: any (but same for input and output)
;	constants: 1 (REAL) : [(srcOrigin[1]-dstOrigin[1]) DIV nComponents,srcOrigin[0]-dstOrigin[0],...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 8, 0, 0, 0

; compute position in the input
add r0.xy, vWinCoord0.xy, cb0[0].xy

ftoi r0, r0
umod r1.z, r0.y, l0.x ; r1.z = y MOD 8
udiv r0.y, r0.y, l0.x ; y := y DIV 8
itof r0, r0

switch r1.z
	
	case 0
		sample_resource(0)_sampler(0) r1, r0
	break
	
	case 1
		sample_resource(1)_sampler(1) r1, r0
	break
	
	case 2
		sample_resource(2)_sampler(2) r1, r0
	break
	
	case 3
		sample_resource(3)_sampler(3) r1, r0
	break
	
	case 4
		sample_resource(4)_sampler(4) r1, r0
	break
	
	case 5
		sample_resource(5)_sampler(5) r1, r0
	break
	
	case 6
		sample_resource(6)_sampler(6) r1, r0
	break
	
	case 7
		sample_resource(7)_sampler(7) r1, r0
	break
	
endswitch

mov o0, r1

end
]]>
	</ILKernel>
	
	<ILKernel name = "SubCopy2DSplit4ToNonVirtAligned_LI_R_LR">		
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when input array is splitted into 4 parts, output array is not virtualized
;	and copy regions are aligned to nComponents (srcOrigin[1] MOD nComponents = 0) 
;	& (dstOrigin[1] MOD nComponents = 0) & (size[1] MOD nComponents) = 0) for both input and output
; 
;	inputs: 4
;	outputs: 1
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: any (but same for input and output)
;	constants: 1 (REAL) : [(srcOrigin[1]-dstOrigin[1]) DIV nComponents,srcOrigin[0]-dstOrigin[0],...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0, 0, 0

; compute position in the input
add r0.xy, vWinCoord0.xy, cb0[0].xy

ftoi r0, r0
umod r1.z, r0.y, l0.x ; r1.z = y MOD 4
udiv r0.y, r0.y, l0.x ; y := y DIV 4
itof r0, r0

switch r1.z
	
	case 0
		sample_resource(0)_sampler(0) r1, r0
	break
	
	case 1
		sample_resource(1)_sampler(1) r1, r0
	break
	
	case 2
		sample_resource(2)_sampler(2) r1, r0
	break
	
	case 3
		sample_resource(3)_sampler(3) r1, r0
	break	
	
endswitch

mov o0, r1

end
]]>
	</ILKernel>
	
	<ILKernel name = "SubCopy2DSplit8ToSplit8Aligned_LI_R_LR">		
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case of splitted arrays and copy regions are aligned to
;	nComponents (srcOrigin[1] MOD nComponents = 0) & (dstOrigin[1] MOD nComponents = 0) 
;	& (subSize[1] MOD nComponents = 0) and 
;	(srcOrigin[0] MOD 8 = 0) & (dstOrigin[0] MOD 8 = 0) & (size[0] MOD 8 = 0)
;	for both input and output
; 
;	inputs: 8
;	outputs: 8
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: any (but same for input and output)
;	constants: 1 (REAL) : [(srcOrigin[1]-dstOrigin[1]) DIV nComponents,(srcOrigin[0]-dstOrigin[0]) DIV 8,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_cb cb0[1]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

add r0.xy, vWinCoord0.xy, cb0[0].xy	; compute position in the input

; load input data
sample_resource(0)_sampler(0) r1, r0
sample_resource(1)_sampler(1) r2, r0
sample_resource(2)_sampler(2) r3, r0
sample_resource(3)_sampler(3) r4, r0
sample_resource(4)_sampler(4) r5, r0
sample_resource(5)_sampler(5) r6, r0
sample_resource(6)_sampler(6) r7, r0
sample_resource(7)_sampler(7) r8, r0

; store to the output
mov o0, r1
mov o1, r2
mov o2, r3
mov o3, r4
mov o4, r5
mov o5, r6
mov o6, r7
mov o7, r8

end
]]>
	</ILKernel>
	
	<ILKernel name = "ClearMemory">
<![CDATA[
il_ps_2_0
;
;	Clear GPU memory resource
; 
;	inputs: 0
;	outputs: 1
;	data type: any
;	nComponents: any
;	constants: 0
;
dcl_output_generic o0
mov r0, r0.0000
mov o0, r0
end
]]>						
	</ILKernel>
	
	<ILKernel name = "Add_R">
<![CDATA[
il_ps_2_0
;
;	Array addition
; 
;	inputs: 2
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
add o0, r0, r1
end		
]]>
	</ILKernel>
	
	<ILKernel name = "AddScalar_R">
<![CDATA[
il_ps_2_0
;
;	Array + Scalar
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
add o0, r0, cb0[0]
end		
]]>
	</ILKernel>
	
	<ILKernel name = "Sub_R">
<![CDATA[
il_ps_2_0
;
;	Array subtraction
; 
;	inputs: 2
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sub o0, r0, r1
end		
]]>
	</ILKernel>
		
	<ILKernel name = "ScalarSub_R">
<![CDATA[
il_ps_2_0
;
;	Scalar - Array
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sub o0, cb0[0], r0
end		
]]>
	</ILKernel>
	
	<ILKernel name = "EwMul_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
mul o0, r0, r1
end
]]>
	</ILKernel>
	
	<ILKernel name = "MulByScalar_R">
<![CDATA[
il_ps_2_0
;
;	Array * Scalar
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
mul o0, r0, cb0[0]
end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwDiv_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication
; 
;	inputs: 2
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
div_zeroop(inf_else_max) o0, r0, r1
end
]]>
	</ILKernel>
	
	<ILKernel name = "DivByScalar_R">
<![CDATA[
il_ps_2_0
;
;	Array / Scalar
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
div_zeroop(inf_else_max) o0, r0, cb0[0]
end		
]]>
	</ILKernel>	
	
	<ILKernel name = "ScalarEwDiv_R">
<![CDATA[
il_ps_2_0
;
;	Scalar ./ Array
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
div_zeroop(inf_else_max) o0, cb0[0], r0
end		
]]>
	</ILKernel>
	
	<ILKernel name = "AddSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Addition of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

add o0, r0, r8
add o1, r1, r9
add o2, r2, r10
add o3, r3, r11
add o4, r4, r12
add o5, r5, r13
add o6, r6, r14
add o7, r7, r15

end		
]]>
	</ILKernel>		
	
	<ILKernel name = "SubSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Subtraction of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

sub o0, r0, r8
sub o1, r1, r9
sub o2, r2, r10
sub o3, r3, r11
sub o4, r4, r12
sub o5, r5, r13
sub o6, r6, r14
sub o7, r7, r15

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwMulSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

mul o0, r0, r8
mul o1, r1, r9
mul o2, r2, r10
mul o3, r3, r11
mul o4, r4, r12
mul o5, r5, r13
mul o6, r6, r14
mul o7, r7, r15

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwDivSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise division of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

div_zeroop(inf_else_max) o0, r0, r8
div_zeroop(inf_else_max) o1, r1, r9
div_zeroop(inf_else_max) o2, r2, r10
div_zeroop(inf_else_max) o3, r3, r11
div_zeroop(inf_else_max) o4, r4, r12
div_zeroop(inf_else_max) o5, r5, r13
div_zeroop(inf_else_max) o6, r6, r14
div_zeroop(inf_else_max) o7, r7, r15

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "AddSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Addition of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

add o0, r0, r4
add o1, r1, r5
add o2, r2, r6
add o3, r3, r7

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "SubSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Subtraction of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)


sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sub o0, r0, r4
sub o1, r1, r5
sub o2, r2, r6
sub o3, r3, r7

end		
]]>
	</ILKernel>		
	
	<ILKernel name = "EwMulSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

mul o0, r0, r4
mul o1, r1, r5
mul o2, r2, r6
mul o3, r3, r7

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwDivSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise division of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

div_zeroop(inf_else_max) o0, r0, r4
div_zeroop(inf_else_max) o1, r1, r5
div_zeroop(inf_else_max) o2, r2, r6
div_zeroop(inf_else_max) o3, r3, r7

end		
]]>
	</ILKernel>
	
	<ILKernel name = "MatMulSplitted8_R">		
<![CDATA[
il_ps_2_0
;
;	Multiplication of matrices splitted into 8 parts: C := A*B
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_cb cb0[1]	; [A.physWidth,...]

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

; parts of A
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

; parts of B
dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; initialize sample counters of A
mov r0.0y, vWinCoord0.y		; r0 := [0,y]
sub r0.x, r0.x, r0.1				; account first increment

; initialize sample counter of B
mov r1.x0, vWinCoord0.x		; [x,0]
sub r1.y, r1.y, l0.y				; account first increment

; clear float4 accumulators for 8x4 * 4x4 matrix multiply result
mov r34, r34.0000	
mov r35, r35.0000
mov r36, r36.0000
mov r37, r37.0000
mov r38, r38.0000	
mov r39, r39.0000
mov r40, r40.0000
mov r41, r41.0000

mov r2.0y00, cb0[0].x			; r2.x is the loop counter, r2.y := A.width
sub r2.x, r2.x, r2.1				; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, l0.y

	; increment sample counter of A
	add r0.x, r0.x, r0.1

	add r2.x, r2.x, r2.1	; loop counter ++

   	ge r2.z, r2.x, r2.y	; while(loop counter < A.physWidth)
   	break_logicalnz r2.z

	; load next 4x4 block of B

	mod r3.x, r2.x, l0.x	; r3.x := r2.x % 2

	eq r3.y, r3.x, r3.0
	if_logicalnz r3.y	; if r3.x == 0
		sample_resource(8)_sampler(8) r10, r1.xy00
		sample_resource(9)_sampler(9) r11, r1.xy00
		sample_resource(10)_sampler(10) r12, r1.xy00
		sample_resource(11)_sampler(11) r13, r1.xy00
	else
		sample_resource(12)_sampler(12) r10, r1.xy00
		sample_resource(13)_sampler(13) r11, r1.xy00
		sample_resource(14)_sampler(14) r12, r1.xy00
		sample_resource(15)_sampler(15) r13, r1.xy00
	endif

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xy00
	sample_resource(1)_sampler(1) r27, r0.xy00
	sample_resource(2)_sampler(2) r28, r0.xy00
	sample_resource(3)_sampler(3) r29, r0.xy00
	sample_resource(4)_sampler(4) r30, r0.xy00
	sample_resource(5)_sampler(5) r31, r0.xy00
	sample_resource(6)_sampler(6) r32, r0.xy00
	sample_resource(7)_sampler(7) r33, r0.xy00

	; compute Ablk * Bblk

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

endloop

; store the result
mov o0, r34
mov o1, r35
mov o2, r36
mov o3, r37
mov o4, r38
mov o5, r39
mov o6, r40
mov o7, r41

end
]]>
	</ILKernel>
	
	<ILKernel name = "MatMulSplitted8Unroll2_R">		
<![CDATA[
il_ps_2_0
;
;	Multiplication of matrices splitted into 8 parts: C := A*B
; 	use loop unrolling by 2
;
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_cb cb0[1]	; [A.physWidth,...]

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; initialize sample counters of A
mov r0.01z0, vWinCoord0.00y0		; r0 := [0,1,y,0]
sub r0.xy, r0.xy, l0.xx					; account first increment

; initialize sample counter of B
mov r1.x0, vWinCoord0.x			; [x,0,1,...]
sub r1.y, r1.y, r1.1					; account first increment

; clear float4 accumulators for 8x4 * 4x4 matrix multiply result
mov r34, r34.0000	
mov r35, r35.0000
mov r36, r36.0000
mov r37, r37.0000
mov r38, r38.0000	
mov r39, r39.0000
mov r40, r40.0000
mov r41, r41.0000

mul r2.0y, l0.y, cb0[0].x	; r2.x is the loop counter, r2.y := floor(A.physWidth/2)
flr r2.y, r2.y
sub r2.x, r2.x, r2.1		; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, r1.1

	; increment sample counters of A
	add r0.xy, r0.xy, l0.xx

	add r2.x, r2.x, r2.1	; loop counter ++

   ge r2.z, r2.x, r2.y	; while(loop counter < floor(A.physWidth/2))
   break_logicalnz r2.z

	; load 2 next 4x4 blocks of B
	sample_resource(8)_sampler(8) r10, r1.xy00
	sample_resource(9)_sampler(9) r11, r1.xy00
	sample_resource(10)_sampler(10) r12, r1.xy00
	sample_resource(11)_sampler(11) r13, r1.xy00

	sample_resource(12)_sampler(12) r14, r1.xy00
	sample_resource(13)_sampler(13) r15, r1.xy00
	sample_resource(14)_sampler(14) r16, r1.xy00
	sample_resource(15)_sampler(15) r17, r1.xy00

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xz00
	sample_resource(1)_sampler(1) r27, r0.xz00
	sample_resource(2)_sampler(2) r28, r0.xz00
	sample_resource(3)_sampler(3) r29, r0.xz00
	sample_resource(4)_sampler(4) r30, r0.xz00
	sample_resource(5)_sampler(5) r31, r0.xz00
	sample_resource(6)_sampler(6) r32, r0.xz00
	sample_resource(7)_sampler(7) r33, r0.xz00

	; compute Ablk * Bblk0

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.yz00
	sample_resource(1)_sampler(1) r27, r0.yz00
	sample_resource(2)_sampler(2) r28, r0.yz00
	sample_resource(3)_sampler(3) r29, r0.yz00
	sample_resource(4)_sampler(4) r30, r0.yz00
	sample_resource(5)_sampler(5) r31, r0.yz00
	sample_resource(6)_sampler(6) r32, r0.yz00
	sample_resource(7)_sampler(7) r33, r0.yz00

	; compute Ablk * Bblk1

	; row 1
	mad r42, r26.x, r14, r34	; r42 := Ablk[0,0]*Bblk1[0,*] + Cblk[0,*]
	mad r42, r26.y, r15, r42	; r42 := Ablk[0,1]*Bblk1[1,*] + r42
	mad r42, r26.z, r16, r42	; r42 := Ablk[0,2]*Bblk1[2,*] + r42
	mad r34, r26.w, r17, r42	; Cblk[0,*] := Ablk[0,3]*Bblk1[3,*] + r42
	; row 2
	mad r42, r27.x, r14, r35
	mad r42, r27.y, r15, r42
	mad r42, r27.z, r16, r42
	mad r35, r27.w, r17, r42
	; row 3
	mad r42, r28.x, r14, r36
	mad r42, r28.y, r15, r42
	mad r42, r28.z, r16, r42
	mad r36, r28.w, r17, r42
	; row 4
	mad r42, r29.x, r14, r37
	mad r42, r29.y, r15, r42
	mad r42, r29.z, r16, r42
	mad r37, r29.w, r17, r42
	; row 5
	mad r42, r30.x, r14, r38
	mad r42, r30.y, r15, r42
	mad r42, r30.z, r16, r42
	mad r38, r30.w, r17, r42
	; row 6
	mad r42, r31.x, r14, r39
	mad r42, r31.y, r15, r42
	mad r42, r31.z, r16, r42
	mad r39, r31.w, r17, r42
	; row 7
	mad r42, r32.x, r14, r40
	mad r42, r32.y, r15, r42
	mad r42, r32.z, r16, r42
	mad r40, r32.w, r17, r42
	; row 8
	mad r42, r33.x, r14, r41
	mad r42, r33.y, r15, r42
	mad r42, r33.z, r16, r42
	mad r41, r33.w, r17, r42

endloop

mul r2.x, r2.x, l0.x	; r2.x is the loop counter, r2.y := 2*floor(A.width/2)
sub r2.x, r2.x, r2.1	; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, l0.y

	; increment sample counters of A
	add r0.x, r0.x, r0.1

	add r2.x, r2.x, r2.1	; loop counter ++

   ge r2.z, r2.x, cb0[0].x	; while(loop counter < A.width)
   break_logicalnz r2.z

	; load next 4x4 block of B

	mod r3.x, r2.x, l0.x	; r3.x := r2.x % 2

	eq r3.y, r3.x, r3.0
	if_logicalnz r3.y	; if r3.x == 0
		sample_resource(8)_sampler(8) r10, r1.xy00
		sample_resource(9)_sampler(9) r11, r1.xy00
		sample_resource(10)_sampler(10) r12, r1.xy00
		sample_resource(11)_sampler(11) r13, r1.xy00
	else
		sample_resource(12)_sampler(12) r10, r1.xy00
		sample_resource(13)_sampler(13) r11, r1.xy00
		sample_resource(14)_sampler(14) r12, r1.xy00
		sample_resource(15)_sampler(15) r13, r1.xy00
	endif

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xz00
	sample_resource(1)_sampler(1) r27, r0.xz00
	sample_resource(2)_sampler(2) r28, r0.xz00
	sample_resource(3)_sampler(3) r29, r0.xz00
	sample_resource(4)_sampler(4) r30, r0.xz00
	sample_resource(5)_sampler(5) r31, r0.xz00
	sample_resource(6)_sampler(6) r32, r0.xz00
	sample_resource(7)_sampler(7) r33, r0.xz00

	; compute Ablk * Bblk

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

endloop

; store the result
mov o0, r34
mov o1, r35
mov o2, r36
mov o3, r37
mov o4, r38
mov o5, r39
mov o6, r40
mov o7, r41
end
]]>
	</ILKernel>
	
	<ILKernel name = "MatVecMulSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Matrix vector multiplication with matrix being splitted into 8 parts: C := A*b
; 
;	inputs: 9
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0

dcl_cb cb0[1]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 0.0f, 0.5f, 0.0f, 0.0f

mov r0, r0.0000	; r0.xy is [x,y] of the first rhs element

flr r2.y, vWinCoord0.x
mul r2.y, r2.y, l0.y
flr r1.0y, r2.y		; r1.xy -> [x,y] of first element in input row
sub r2.y, r2.y, r1.y	; remainder of division by 2

sub r0.x, r0.x, r0.1		; account first increment
sub r1.x, r1.x, r1.1		; account first increment

mov r20, r20.0000
mov r21, r21.0000
mov r22, r22.0000
mov r23, r23.0000

mov r10, r10.0000			; loop counter
sub r10.x, r10.x, r10.1	; account first increment

mov r11, cb0[0]

eq r2.z, r2.y, r2.0
if_logicalnz r2.z	; if frac(y/2) == 0

	whileloop

		; increment counters of row elements
		add r0.x, r0.x, r0.1
		add r1.x, r1.x, r1.1

		add r10.x, r10.x, r10.1	; loop counter ++
		ge r10.y, r10.x, r11.x	; while(loop counter < cb0[0].x)
		break_logicalnz r10.y

		; load next part of rhs
		sample_resource(8)_sampler(8) r5, r0.xy

		; load next parts from 4 rows
		sample_resource(0)_sampler(0) r6, r1.xy
		sample_resource(1)_sampler(1) r7, r1.xy
		sample_resource(2)_sampler(2) r8, r1.xy
		sample_resource(3)_sampler(3) r9, r1.xy

		; do elementwise multiply	
		mad r20, r5, r6, r20
		mad r21, r5, r7, r21
		mad r22, r5, r8, r22
		mad r23, r5, r9, r23
	endloop

else

	whileloop

		; increment counters of row elements
		add r0.x, r0.x, r0.1
		add r1.x, r1.x, r1.1

		add r10.x, r10.x, r10.1	; loop counter ++
		ge r10.y, r10.x, r11.x	; while(loop counter < cb0[0].x)
		break_logicalnz r10.y

		; load next part of rhs
		sample_resource(8)_sampler(8) r5, r0.xy

		; load next parts from 4 rows
		sample_resource(4)_sampler(4) r6, r1.xy
		sample_resource(5)_sampler(5) r7, r1.xy
		sample_resource(6)_sampler(6) r8, r1.xy
		sample_resource(7)_sampler(7) r9, r1.xy

		; do elementwise multiply	
		mad r20, r5, r6, r20
		mad r21, r5, r7, r21
		mad r22, r5, r8, r22
		mad r23, r5, r9, r23
	endloop

endif

; now do final horizontal add
dp4 r30.x, r20, r20.1111	; r +* ones == r.x+r.y+r.z+r.w
dp4 r30.y, r21, r21.1111
dp4 r30.z, r22, r22.1111
dp4 r30.w, r23, r23.1111

mov o0, r30

end
]]>
	</ILKernel>

	<ILKernel name = "ConvolveRows5_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 5 coefficients FIR filter: y[k] = sum_m(h[m]*x[k+m])
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x ; x := x*4

; input position in single component elements
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r13.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r13.x, r13.x, l1.x ; x MOD 4

; load input data

ine r13.y, r13.x, r13.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	
	call 0 ; get input data in r0, r1
else
	
	sample_resource(0)_sampler(0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0 and r1 registers given r10, r11, r12 and r13.x = (x MOD 4)
func 0
	
	switch r13.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0 and r1, result is returned in r10
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10

	mul r11, r0, cb0[2]
	mad r11, r1, cb0[3], r11

	mul r12, r0, cb0[4]
	mad r12, r1, cb0[5], r12

	mul r13, r0, cb0[6]
	mad r13, r1, cb0[7], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>
	
	<ILKernel name = "ConvolveRows9_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 9 coefficients FIR filter: y[k] = sum_m(h[m]*x[k+m])
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 12x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x ; x := x*4

; input position in single component elements
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r14.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r14.x, r14.x, l1.x ; x MOD 4

; load input data

ine r14.y, r14.x, r14.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r13, r20.xy
	
	call 0 ; get input data in r0, r1, r2
else
	
	sample_resource(0)_sampler(0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r2, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0, r1, r2 registers given r10, r11, r12, r13 and r14.x = (x MOD 4)
func 0
	
	switch r14.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
			
			mov r2.xyz_, r12.yzw0
			mov r2.w, r13.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
			
			mov r2.xy__, r12.zw00
			mov r2.__zw, r13.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
			
			mov r2.x___, r12.w000
			mov r2._yzw, r13.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0, r1, r2,  result is returned in r10
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10
	mad r10, r2, cb0[2], r10

	mul r11, r0, cb0[3]
	mad r11, r1, cb0[4], r11
	mad r11, r2, cb0[5], r11

	mul r12, r0, cb0[6]
	mad r12, r1, cb0[7], r12
	mad r12, r2, cb0[8], r12

	mul r13, r0, cb0[9]
	mad r13, r1, cb0[10], r13
	mad r13, r2, cb0[11], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>
	
	<ILKernel name = "ConvolveRows12_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 12 coefficients FIR filter: y[k] = sum_m(h[m]*x[k+m])
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 16x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,h9,h10,h11],[h12,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,h9,h10],[h11,h12,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,h9],[h10,h11,h12,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8],[h9,h10,h11,h12]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x ; x := x*4

; input position in single component elements
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r15.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r15.x, r15.x, l1.x ; x MOD 4

; load input data

ine r15.y, r15.x, r15.0 ; (x MOD 4) # 0
if_logicalnz r15.y

	sample_resource(0)_sampler(0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r13, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(4,0,0) r14, r20.xy
	
	call 0 ; get input data in r0, r1, r2, r3
else
	
	sample_resource(0)_sampler(0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r2, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r3, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0, r1, r2, r3 registers given r10, r11, r12, r13, r14 and r15.x = (x MOD 4)
func 0
	
	switch r15.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
			
			mov r2.xyz_, r12.yzw0
			mov r2.w, r13.x
			
			mov r3.xyz_, r13.yzw0
			mov r3.w, r14.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
			
			mov r2.xy__, r12.zw00
			mov r2.__zw, r13.00xy
			
			mov r3.xy__, r13.zw00
			mov r3.__zw, r14.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
			
			mov r2.x___, r12.w000
			mov r2._yzw, r13.0xyz
			
			mov r3.x___, r13.w000
			mov r3._yzw, r14.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0, r1, r2, r3  result is returned in r10
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10
	mad r10, r2, cb0[2], r10
	mad r10, r3, cb0[3], r10

	mul r11, r0, cb0[4]
	mad r11, r1, cb0[5], r11
	mad r11, r2, cb0[6], r11
	mad r11, r3, cb0[7], r11

	mul r12, r0, cb0[8]
	mad r12, r1, cb0[9], r12
	mad r12, r2, cb0[10], r12
	mad r12, r3, cb0[11], r12

	mul r13, r0, cb0[12]
	mad r13, r1, cb0[13], r13
	mad r13, r2, cb0[14], r13
	mad r13, r3, cb0[15], r13	
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>
	
	<ILKernel name = "TransposeSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Transposition of matrices splitted into 8 parts
; 
;	inputs: 8
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; compute position in the input
flr r0.xy, vWinCoord0.yx
mul r0.xy, r0.xy, l0.xy ; [x*2, y/ 2]
frc r1.y, r0.y ; r1.y := frac(y/2)
flr r0.y, r0.y

eq r1.z, r1.y, r1.0
if_logicalnz r1.z	; if frac(y/2) == 0

	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r1, r0.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r2, r0.xy
	
	sample_resource(1)_sampler(1)_aoffimmi(0,0,0) r3, r0.xy
	sample_resource(1)_sampler(1)_aoffimmi(1,0,0) r4, r0.xy
	
	sample_resource(2)_sampler(2)_aoffimmi(0,0,0) r5, r0.xy
	sample_resource(2)_sampler(2)_aoffimmi(1,0,0) r6, r0.xy
	
	sample_resource(3)_sampler(3)_aoffimmi(0,0,0) r7, r0.xy
	sample_resource(3)_sampler(3)_aoffimmi(1,0,0) r8, r0.xy
else			
		
	sample_resource(4)_sampler(4)_aoffimmi(0,0,0) r1, r0.xy
	sample_resource(4)_sampler(4)_aoffimmi(1,0,0) r2, r0.xy
	
	sample_resource(5)_sampler(5)_aoffimmi(0,0,0) r3, r0.xy
	sample_resource(5)_sampler(5)_aoffimmi(1,0,0) r4, r0.xy
	
	sample_resource(6)_sampler(6)_aoffimmi(0,0,0) r5, r0.xy
	sample_resource(6)_sampler(6)_aoffimmi(1,0,0) r6, r0.xy
	
	sample_resource(7)_sampler(7)_aoffimmi(0,0,0) r7, r0.xy
	sample_resource(7)_sampler(7)_aoffimmi(1,0,0) r8, r0.xy
endif

	mov r10.x, r1.x
	mov r10.y, r3.x
	mov r10.z, r5.x
	mov r10.w, r7.x	
	
	mov r11.x, r1.y
	mov r11.y, r3.y
	mov r11.z, r5.y
	mov r11.w, r7.y
	
	mov r12.x, r1.z
	mov r12.y, r3.z
	mov r12.z, r5.z
	mov r12.w, r7.z
	
	mov r13.x, r1.w
	mov r13.y, r3.w
	mov r13.z, r5.w
	mov r13.w, r7.w
	
	;
	
	mov r14.x, r2.x
	mov r14.y, r4.x
	mov r14.z, r6.x
	mov r14.w, r8.x 
	
	mov r15.x, r2.y
	mov r15.y, r4.y
	mov r15.z, r6.y
	mov r15.w, r8.y
	
	mov r16.x, r2.z
	mov r16.y, r4.z
	mov r16.z, r6.z
	mov r16.w, r8.z
	
	mov r17.x, r2.w
	mov r17.y, r4.w
	mov r17.z, r6.w
	mov r17.w, r8.w
	
	mov o0, r10
	mov o1, r11
	mov o2, r12
	mov o3, r13
	mov o4, r14
	mov o5, r15
	mov o6, r16
	mov o7, r17		
	
end		
]]>
	</ILKernel>	
	
	<ILKernel name = "ConvolveRows5Down2_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 5 coefficients FIR filter combined with downsampling by 2
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 8.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in multi component elements
flr r0.xy, vWinCoord0.xy

; input position in single component elements
mul r0.x, r0.x, l0.x
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r13.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r14.x, r13.x, l1.x ; x MOD 4

; load input data

ine r13.y, r14.x, r14.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r13, r20.xy
	
	call 0 ; get input data in r0, r1, r2
else
	
	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r2, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0, r1, r2 registers given r10, r11, r12, r13 and r14.x = (x MOD 4)
func 0
	
	switch r14.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
			
			mov r2.xyz_, r12.yzw0
			mov r2.w, r13.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
			
			mov r2.xy__, r12.zw00
			mov r2.__zw, r13.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
			
			mov r2.x___, r12.w000
			mov r2._yzw, r13.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0, r1, r2 result is returned in r10
func 1
	
	; #TODO:  optimize
	
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10

	mul r11, r0, cb0[2]
	mad r11, r1, cb0[3], r11

	mul r12, r0, cb0[4]
	mad r12, r1, cb0[5], r12

	mul r13, r0, cb0[6]
	mad r13, r1, cb0[7], r13
	
	dp4 r14.x, r10, r10.1111
	dp4 r14.y, r11, r11.1111
	dp4 r14.z, r12, r12.1111
	dp4 r14.w, r13, r13.1111
	
	mul r10, r1, cb0[0]
	mad r10, r2, cb0[1], r10

	mul r11, r1, cb0[2]
	mad r11, r2, cb0[3], r11

	mul r12, r1, cb0[4]
	mad r12, r2, cb0[5], r12

	mul r13, r1, cb0[6]
	mad r13, r2, cb0[7], r13
	
	dp4 r15.x, r10, r10.1111
	dp4 r15.y, r11, r11.1111
	dp4 r15.z, r12, r12.1111
	dp4 r15.w, r13, r13.1111
	
	mov r10.xy__, r14.xz00
	mov r10.__zw, r15.00xz
ret
endfunc

end
]]>
	</ILKernel>
	
	<ILKernel name = "ConvolveRows5Up2_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 5 coefficients FIR filter combined with upsampling by 2
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.5f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x ; x := x*4
sub r0.x, r0.x, cb1[0].x ; x - hotSpot

; input position in single component elements
add r0.x, r0.x, r0.1 ; x := x + 1
mul r0.x, r0.x, l0.z ; x := x / 2
frc r14.x, r0.x ; fraction(x/2)
ftoi r13.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r13.x, r13.x, l1.x ; x MOD 4

; load input data

ine r13.y, r13.x, r13.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy		
	
	call 0 ; get input data in r0		
else
	
	sample_resource(0)_sampler(0) r0, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0 register given r10, r11 and r13.x = (x MOD 4)
func 0
	
	switch r13.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x						
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy						
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0 and r14.x = fraction(x/2), result is returned in r10
func 1
	
	; account upsampling by 2
	ne r14.x, r14.x, r14.0 ; fraction(x/2) # 0
	if_logicalnz r14.x
		
		mov r1.x0z0, r0.x0y0
		mov r2.x0z0, r0.z0w0
	else
		
		mov r1.0y0w, r0.0x0y
		mov r2.0y0w, r0.0z0w
	endif
	
	mul r10, r1, cb0[0]
	mad r10, r2, cb0[1], r10

	mul r11, r1, cb0[2]
	mad r11, r2, cb0[3], r11

	mul r12, r1, cb0[4]
	mad r12, r2, cb0[5], r12

	mul r13, r1, cb0[6]
	mad r13, r2, cb0[7], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>		
	
	
	<ILKernel name = "Inv8x8_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Inversion of a matrix 8x8
; 
;	inputs: 0
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 0
;

dcl_literal l0, 16, 0, 0, 0

umul r16.x, vaTid.x, l0.x

; load input matrix

mov r0, g[r16.x]
mov r1, g[r16.x+1]
mov r2, g[r16.x+2]
mov r3, g[r16.x+3]

mov r4, g[r16.x+4]
mov r5, g[r16.x+5]
mov r6, g[r16.x+6]
mov r7, g[r16.x+7]

mov r8, g[r16.x+8]
mov r9, g[r16.x+9]
mov r10, g[r16.x+10]
mov r11, g[r16.x+11]

mov r12, g[r16.x+12]
mov r13, g[r16.x+13]
mov r14, g[r16.x+14]
mov r15, g[r16.x+15]

call 4

umul r16.x, vaTid.x, l0.x

; store matrix inverse
mov g[r16.x], r0
mov g[r16.x+1], r1
mov g[r16.x+2], r2
mov g[r16.x+3], r3

mov g[r16.x+4], r4
mov g[r16.x+5], r5
mov g[r16.x+6], r6
mov g[r16.x+7], r7

mov g[r16.x+8], r8
mov g[r16.x+9], r9
mov g[r16.x+10], r10
mov g[r16.x+11], r11

mov g[r16.x+12], r12
mov g[r16.x+13], r13
mov g[r16.x+14], r14
mov g[r16.x+15], r15

endmain

; 2x2 matrix multiplication
;	r0: [x, y; z,w] - lhs, r1: [x, y; z,w] - rhs
;	result is in r0, uses r>=100 as stack
func 0
	; push to the stack
	mov r100, r2
	
	; first row of the result
	mul r2.xy, r0.xx, r1.xy
	mad r0.xy, r0.yy, r1.zw, r2.xy
	
	; second row of the result
	mul r2.xy, r0.zz, r1.xy
	mad r0.__zw, r0.00ww, r1.00zw, r2.00xy
	
	; pop from the stack
	mov r2, r100
ret
endfunc

; 4x4 matrix multiplication
;	r0, r1, r2, r3 - lhs, r4, r5, r6, r7 - rhs
;	result is in r0, r1, r2, r3, uses r>=101 as stack
func 1
	; push to the stack
	mov r101, r8
	
	; row 1
	mul r8, r0.xxxx, r4
	mad r8, r0.yyyy, r5, r8
	mad r8, r0.zzzz, r6, r8
	mad r0, r0.wwww, r7, r8
	
	; row 2
	mul r8, r1.xxxx, r4
	mad r8, r1.yyyy, r5, r8
	mad r8, r1.zzzz, r6, r8
	mad r1, r1.wwww, r7, r8
	
	; row 3
	mul r8, r2.xxxx, r4
	mad r8, r2.yyyy, r5, r8
	mad r8, r2.zzzz, r6, r8
	mad r2, r2.wwww, r7, r8
	
	; row 4	
	mul r8, r3.xxxx, r4
	mad r8, r3.yyyy, r5, r8
	mad r8, r3.zzzz, r6, r8
	mad r3, r3.wwww, r7, r8					
	
	; pop from the stack
	mov r8, r101
ret
endfunc

; inversion of a 2x2 matrix
; matrix is stored in r0, result is given in r0, function uses r>=102 as stack
;	r0: 
;		[ x  y ]
;		[ z w ]
;
; inverse:
;
;		[ w -y ]	           1
;					* ---------------
;		[ -z  x ]		x*w - y*z
func 2
	mov r102, r1 ; push r1 to the stack
	
	mul r1.xy, r0.xy00, r0.wz00 ; [x*w,y*z]
	sub r1.x, r1.x, r1.y ; x*w-y*z
	
	mov r0.x__w, r0.w00x ; x <-> w
	mov r0.yz, r0_neg(yz)
	div_zeroop(inf_else_max) r0, r0, r1.xxxx ; ./(x*w-y*z)
	
	mov r1, r102 ; pop r1 from the stack
ret
endfunc

; inversion of a 4x4 matrix
; matrix is stored in r0, r1, r2, r3, result is given in same registers, function uses r>=103 as stack
;
;		[ r0.x  r0.y | r0.z r0.w ]
;		[ r1.x  r1.y | r1.z r1.w ]		[ A | B ]
;		------------------------------ =	--------- 
;		[ r2.x  r2.y | r2.z r2.w ]		[C  | D]
;		[ r3.x  r3.y | r3.z r3.w ]
;
; inverse:
;
;	
;		W := inv(D)
;		X := B*W
;		Y := W*C
;
;		IA := inv(A-X*C)
;		IB := -IA*X
;		IC := -Y*IA
;		ID := W-Y*IB
;
func 3
	mov r103, r4
	mov r104, r5
	mov r105, r6
	
	; C
	mov r4, r3.00xy
	mov r4.xy, r2.xy	
	
	; D
	mov r5, r3
	mov r5.xy__, r2.zw00
	
	mov r2, r4 ; r2 = C
	mov r3, r5 ; r3 = D
	
	; r4 = A
	mov r4, r1.00xy
	mov r4.xy, r0.xy
	
	; r5 = B
	mov r5, r1
	mov r5.xy__, r0.zw00
	
	; compute W = inv(D)
	mov r0, r3 ; D
	call 2
	mov r3, r0 ; r3 = W
	
	mov r1, r2 ; C
	call 0 ; W*C
	mov r6, r0 ; r6 = Y
	
	mov r0, r5 ; B
	mov r1, r3 ; W
	call 0
	mov r5, r0 ; r5 = X
	
	mov r1, r2 ; C
	call 0 ; r0 = X*C
	sub r0, r4, r0 ; r0 = A-X*C
	call 2
	mov r4, r0 ; r4 := IA
	
	mov r1, r5 ; X
	call 0 ; r0 := IA*X = -IB
	mov r5, r0_neg(xyzw) ; r5 = IB
	
	mov r0, r6 ; Y
	mov r1, r4 ; IA
	call 0 ; r0 = Y*IA
	mov r2, r0_neg(xyzw) ; r2 = IC

	mov r0, r6
	mov r1, r5
	call 0 ; r0 = Y*IB
	sub r3, r3, r0 ; r3 = ID = W-Y*IB
	
	; convert to original format
				
	mov r0.xy, r4.xy
	mov r0.__zw, r5.00xy
	
	mov r1, r5
	mov r1.xy__, r4.zw00
	
	mov r4, r2
	mov r5, r3
	
	mov r2.xy, r4.xy
	mov r2.__zw, r5.00xy
	
	mov r3, r5
	mov r3.xy__, r4.zw00
	
	; pop from the stack
	mov r4, r103
	mov r5, r104
	mov r6, r105	
ret
endfunc

; inversion of a 8x8 matrix
; matrix is stored in r0-r15, result is given in same registers, function uses r>=106 as stack
;
;		[ r0   |  r1  ]
;		[ r2   |  r3  ]		
;		[ r4   |  r5  ] 
;		[ r6   |  r7  ]		[ A | B ]
;		---------------- =	--------- 
;		[ r8   | r9   ] 		[C  | D]
;		[ r10 | r11 ]		
;		[ r12 | r13 ] 
;		[ r14 | r15 ]
;
; inverse:
;
;	
;		W := inv(D)
;		X := B*W
;		Y := W*C
;
;		IA := inv(A-X*C)
;		IB := -IA*X
;		IC := -Y*IA
;		ID := W-Y*IB
;
func 4
;	; push to the stack
;	mov r106, r16
;	mov r107, r17
;	mov r108, r18
;	mov r109, r19	
;	mov r110, r20
;	mov r111, r21
;	mov r112, r22
;	mov r113, r23
	
	; keep r0-r7 unchanged
	mov r16, r0
	mov r17, r1
	mov r18, r2
	mov r19, r3	
	mov r20, r4
	mov r21, r5
	mov r22, r6
	mov r23, r7
	
	; compute W = inv(D)
	
	; load D
	mov r0, r9
	mov r1, r11
	mov r2, r13
	mov r3, r15
	call 3 ; r0-r3 = W = inv(D)
	
	; store W
	mov r9, r0
	mov r11, r1
	mov r13, r2
	mov r15, r3		
	
	; load B to r0-r3
	mov r0, r17
	mov r1, r19
	mov r2, r21
	mov r3, r23
	
	; load W to r4-r7
	mov r4, r9
	mov r5, r11
	mov r6, r13
	mov r7, r15
	call 1 ; r0-r3 = X = B*W
	
	; store X in B
	mov r17, r0
	mov r19, r1
	mov r21, r2
	mov r23, r3
	
	; load C
	mov r4, r8
	mov r5, r10
	mov r6, r12
	mov r7, r14
	call 1 ; r0-r3 = X*C
	
	; compute A-X*C
	sub r0, r16, r0
	sub r1, r18, r1
	sub r2, r20, r2
	sub r3, r22, r3
	call 3 ; r0-r3 = IA = inv(A-X*C)
	
	; store IA
	mov r16, r0
	mov r18, r1
	mov r20, r2
	mov r22, r3
	
	;load X
	mov r4, r17_neg(xyzw)
	mov r5, r19_neg(xyzw)
	mov r6, r21_neg(xyzw)
	mov r7, r23_neg(xyzw)
	call 1 ; r0-r3 = IB = -IA*X
	
	; store IB
	mov r17, r0
	mov r19, r1
	mov r21, r2
	mov r23, r3
	
	; compute Y
	;
	
	; load W and C
	mov r0, r9
	mov r1, r11
	mov r2, r13
	mov r3, r15
	
	mov r4, r8
	mov r5, r10
	mov r6, r12
	mov r7, r14
	call 1 ; r0-r3 = Y = W*C
	
	; store Y in C
	mov r8, r0
	mov r10, r1
	mov r12, r2
	mov r14, r3
	
	; load IB
	mov r4, r17	
	mov r5, r19
	mov r6, r21
	mov r7, r23
	call 1 ; r0-r3 = Y*IB
	
	; compute ID = W-Y*IB
	sub r9, r9, r0
	sub r11, r11, r1
	sub r13, r13, r2
	sub r15, r15, r3
	
	; compute IC = -Y*IA 
	
	; load Y
	mov r0, r8
	mov r1, r10
	mov r2, r12
	mov r3, r14
	
	; load IA
	mov r4, r16_neg(xyzw)
	mov r5, r18_neg(xyzw)
	mov r6, r20_neg(xyzw)
	mov r7, r22_neg(xyzw)
	call 1 ; r0-r3 = IC
	
	; store IC
	mov r8, r0
	mov r10, r1
	mov r12, r2
	mov r14, r3
	
	; store IA
	mov r0, r16
	mov r2, r18
	mov r4, r20
	mov r6, r22
	
	; store IB
	mov r1, r17
	mov r3, r19
	mov r5, r21
	mov r7, r23
	
;	; pop from the stack
;	mov r16, r106
;	mov r17, r107
;	mov r18, r108
;	mov r19, r109
;	mov r20, r110
;	mov r21, r111
;	mov r22, r112
;	mov r23, r113
ret
endfunc

end		
]]>
	</ILKernel>
	
	<ILKernel name = "Transpose3D_LI_R_LR">
<![CDATA[
il_ps_2_0
;
;	3D Array transposition
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: 1
;	constants: 1, 3x4 (LONGINT) [physWidth, newNy*newNx, newNx, 1], [tZ, tY, tX, 0], [oldNy*oldNx, oldNx, 1, 0]
;
dcl_cb cb0[3]
dcl_output_generic o0
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

; compute linear index in the output
ftoi r5, vWinCoord0
umad r0.x, r5.y, cb0[0].x, r5.x

; compute z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; z := ind/(newNy*newNx)
umod r1.z, r0.x, cb0[0].y	; r1.z := ind - z*newNy*newNx
udiv r1.y, r1.z, cb0[0].z	; y := (ind - z*newNy*newNx)/newNx
umod r1.z, r1.z, cb0[0].z	; x := ind - z*newNy*newNx - y*newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

endswitch

; compute linear index in the input
imul r2.xyz, r2.xyz, cb0[2].xyz	; [z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z

; compute corresponding 2D index in the input
umod r3.x, r2.x, cb0[0].x	; x := index MOD physWidth
udiv r3.y, r2.x, cb0[0].x	; y := index DIV physWidth
itof r3, r3

sample_resource(0)_sampler(0) o0, r3.xy

end
]]>
	</ILKernel>
	
	<ILKernel name = "Transpose4D_LI_R_LR">
<![CDATA[
il_ps_2_0
;
;	4D Array transposition
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: 1
;	constants: 1, 3x4 (LONGINT) [physWidth, newNz*newNy*newNx, newNy*newNx, newNx], 
;											[tT, tZ, tY, tX], [oldNz*oldNy*oldNx, oldNy*oldNx, oldNx, 1]
;
dcl_cb cb0[3]
dcl_output_generic o0
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

; compute linear index in the output
ftoi r5, vWinCoord0
umad r0.x, r5.y, cb0[0].x, r5.x

; compute t, z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; t := ind/(newNz*newNy*newNx)
umod r1.w, r0.x, cb0[0].y	; r1.w := ind - t*newNz*newNy*newNx
udiv r1.y, r1.w, cb0[0].z	; z := (ind - t*newNz*newNy*newNx)/(newNy*newNx)
umod r1.w, r1.w, cb0[0].z	; r1.w := ind - t*newNz*newNy*newNx - z*(newNy*newNx)
udiv r1.z, r1.w, cb0[0].w	; y := (ind - t*newNz*newNy*newNx - z*(newNy*newNx))/newNx
umod r1.w, r1.w, cb0[0].w	; x := (ind - t*newNz*newNy*newNx - z*(newNy*newNx)) MOD newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break
	
	case 3
		mov r2.w, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

	case 3
		mov r2.w, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

	case 3
		mov r2.w, r1.z
	break

endswitch

switch cb0[1].w

	default
		mov r2.x, r1.w
	break

	case 1
		mov r2.y, r1.w
	break

	case 2
		mov r2.z, r1.w
	break

	case 3
		mov r2.w, r1.w
	break

endswitch

; compute linear index in the input
imul r2.xyzw, r2.xyzw, cb0[2].xyzw	; [t*oldNz*oldNy*oldNx, z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z
iadd r2.x, r2.x, r2.w

; compute corresponding 2D index in the input
umod r3.x, r2.x, cb0[0].x	; x := index MOD physWidth
udiv r3.y, r2.x, cb0[0].x	; y := index DIV physWidth
itof r3, r3

sample_resource(0)_sampler(0) o0, r3.xy

end
]]>
	</ILKernel>
	
	<ILKernel name = "ReshapeNDToSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Reshape a ND array to a splitted matrix
; 
;	inputs: 2
;	outputs: 8
;	data type: REAL
;	nComponents: 1 for input, 4 for output
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)


end		
]]>
	</ILKernel>	
	
	<ILKernel name = "Transpose2DVirtToVirt_LI_R_LR">
<![CDATA[
il_ps_2_0
;
;	Transposition of a 2D virtualized array resulting in a virtualized array: C := A.Transpose
; 
;	inputs: 1
;	outputs: 1
;	global buffer: No
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: 1
;	constants: 1, 1x4 (LONGINT)
;	
dcl_cb cb0[1] ; [physWidth,A.width,C.width,...]
dcl_output_generic o0
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

; compute linear index in the output
ftoi r0.xy, vWinCoord0.xy
umad r0.x, r0.y, cb0[0].x, r0.x ; ind := y*physWidth + x

; compute non-virtual position in the output
udiv r0.y, r0.x, cb0[0].z ; y := ind DIV C.Width
umod r0.x, r0.x, cb0[0].z

; non-virtual position in the input
mov r0.xy, r0.yx

; linear index in the input
umad r0.x, r0.y, cb0[0].y, r0.x

; virtual position in the input
udiv r0.y, r0.x, cb0[0].x ; y := ind DIV physWidth
umod r0.x, r0.x, cb0[0].x

itof r0.xy, r0.xy
sample_resource(0)_sampler(0) o0, r0.xy

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveRows5Virt_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve set of lines in a virtualized memory layout with 5 taps FIR kernel
;	each thread processes a single line
; 
;	inputs: 1
;	outputs: 0
;	data type: REAL
;	global buffer: Yes
;	nComponents: 1
;	constants: 2, 8x4 (REAL) and 1x4 (LONGINT)
;
dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,width,physWidth,boundary]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, -4, -1, 1

; compute linear index of first element of line to process
umul r20.x, vaTid.x, cb1[0].y ; iLine*width

; output index
iadd r21.x, r20.x, cb1[0].x ; inp.ind + hotSpot
umod r21.z, r21.x, l0.x ; out.ind MOD 4
imad r21.z, r21.z, l0.z, l0.x ; 4 - (out.ind MOD 4)

; shift pointers to be aligned to 4 components
iadd r20.x, r20.x, r21.z
iadd r21.x, r21.x, r21.z
udiv r21.x, r21.x, l0.x ; output position in quads

; compute right input bound
iadd r21.y, cb1[0].y, l0.y ; width - 4
imad r21.y, r21.z, l0.z, r21.y ; width-4-(4 - (out.ind MOD 4))
udiv r21.y, r21.y, l0.x ; (width-4-(4 - (out.ind MOD 4))) DIV 4
umul r21.y, r21.y, l0.x ; 4*((width-4-(4 - (out.ind MOD 4))) DIV 4)
iadd r21.y, r20.x, r21.y

ine r20.z, cb1[0].x, r20.0 ; hotSpot # 0
if_logicalnz r20.z	
	; process left boundary	
endif

; load first quads
call 0
mov r0, r9

iadd r20.x, r20.x, l0.x
call 0
mov r1, r9

; compute result
call 1
mov g[r21.x], r10

whileloop
	
	iadd r20.x, r20.x, l0.x ; INC(inp.ind,4)
	iadd r21.x, r21.x, l0.w ; INC(out.ind,1)
	
	ige r21.z, r20.x, r21.y ; inp.ind >= right bound
	break_logicalnz r21.z
				
	mov r0, r1 ; keep old quad
	call 0 ; load new quad
	mov r1, r9
	
	; compute result
	call 1
	
	; store result
	mov g[r21.x], r10	
endloop

; process right boundary

endmain

; loading next quad given linear index in r20.x, loaded quad is in r9, r20.x is not incremented, uses r22.xyz
; TODO: optimize!!!
func 0	
	
	mov r22.z, r20.x		
	
	umod r22.x, r22.z, cb1[0].z
	udiv r22.y, r22.z, cb1[0].z
	
	iadd r22.w, r22.x, l0.x
	lt r22.w, r22.w, cb1[0].z
	if_logicalnz r22.w
		sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r9.x, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r9.y, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r9.z, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r9.w, r22.xy
	else		
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.x, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.y, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.z, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.w, r22.xy		
	endif	
ret
endfunc

; function for computing the convolution given r0 and r1, result is returned in r10, uses r11-r13
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10

	mul r11, r0, cb0[2]
	mad r11, r1, cb0[3], r11

	mul r12, r0, cb0[4]
	mad r12, r1, cb0[5], r12

	mul r13, r0, cb0[6]
	mad r13, r1, cb0[7], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>	
	

<ILKernel name = "ConvolveRows9Virt_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve set of lines in a virtualized memory layout with 9 taps FIR kernel
;	each thread processes a single line
; 
;	inputs: 1
;	outputs: 0
;	data type: REAL
;	global buffer: Yes
;	nComponents: 1
;	constants: 2, 8x4 (REAL) and 1x4 (LONGINT)
;
dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[1]	; [hotSpot,width,physWidth,boundary]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, -8, -1, 1

; compute linear index of first element of line to process
umul r20.x, vaTid.x, cb1[0].y ; iLine*width

; output index
iadd r21.x, r20.x, cb1[0].x ; inp.ind + hotSpot
umod r21.z, r21.x, l0.x ; out.ind MOD 4
imad r21.z, r21.z, l0.z, l0.x ; 4 - (out.ind MOD 4)

; shift pointers to be aligned to 4 components
iadd r20.x, r20.x, r21.z
iadd r21.x, r21.x, r21.z
udiv r21.x, r21.x, l0.x ; output position in quads

; compute right input bound
iadd r21.y, cb1[0].y, l0.y ; width - 8
imad r21.y, r21.z, l0.z, r21.y ; width-8-(4 - (out.ind MOD 4))
udiv r21.y, r21.y, l0.x ; (width-8-(4 - (out.ind MOD 4))) DIV 4
umul r21.y, r21.y, l0.x ; 4*((width-8-(4 - (out.ind MOD 4))) DIV 4)
iadd r21.y, r20.x, r21.y

ine r20.z, cb1[0].x, r20.0 ; hotSpot # 0
if_logicalnz r20.z	
	; process left boundary	
endif

; load first quads
call 0
mov r0, r9

iadd r20.x, r20.x, l0.x
call 0
mov r1, r9

iadd r20.x, r20.x, l0.x
call 0
mov r2, r9

; compute result
call 1
mov g[r21.x], r10

whileloop
	
	iadd r20.x, r20.x, l0.x ; INC(inp.ind,4)
	iadd r21.x, r21.x, l0.w ; INC(out.ind,1)
	
	ige r21.z, r20.x, r21.y ; inp.ind >= right bound
	break_logicalnz r21.z
				
	mov r0, r1 ; keep old quads
	mov r1, r2
	call 0 ; load new quad
	mov r2, r9
	
	; compute result
	call 1
	
	; store result
	mov g[r21.x], r10
endloop

; process right boundary

endmain

; loading next quad given linear index in r20.x, loaded quad is in r9, r20.x is not incremented, uses r22.xyz
; TODO: optimize!!!
func 0	
	
	mov r22.z, r20.x		
	
	umod r22.x, r22.z, cb1[0].z
	udiv r22.y, r22.z, cb1[0].z
	
	iadd r22.w, r22.x, l0.x
	lt r22.w, r22.w, cb1[0].z
	if_logicalnz r22.w
		sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r9.x, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r9.y, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r9.z, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r9.w, r22.xy
	else		
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.x, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.y, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.z, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.w, r22.xy		
	endif	
ret
endfunc

; function for computing the convolution given r0, r1, r2,  result is returned in r10, uses r11, r12, r13
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10
	mad r10, r2, cb0[2], r10

	mul r11, r0, cb0[3]
	mad r11, r1, cb0[4], r11
	mad r11, r2, cb0[5], r11

	mul r12, r0, cb0[6]
	mad r12, r1, cb0[7], r12
	mad r12, r2, cb0[8], r12

	mul r13, r0, cb0[9]
	mad r13, r1, cb0[10], r13
	mad r13, r2, cb0[11], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>	
	

<ILKernel name = "TestCS">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
dcl_lds_size_per_thread 16
dcl_lds_sharing_mode _wavefrontRel
;
;	testing compute shader
; 
;	inputs: 0
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 1
;	constants: 0
;

itof r1.x, vaTid.x

fence_lds_memory

lds_write_vec mem.x, r1.x

fence_lds_memory

lds_read_vec g[0].x, r2.00

end
]]>
	</ILKernel>
	
<ILKernel name = "Convolve3DX5_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve 3D virtualized array along X (last) direction with up to 5 taps FIR filter
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,width,physWidth,xPitch], [boundary,...]

; hotSpot - has to be aligned to be multiple of 4

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 1, 16, 4, -1
dcl_literal l1, 4.0f, 0.0f, 0.0f, 0.0f

umul r20.x, vaTid.x, cb1[0].w ; iLine*xPitch -> output index in quads

; 2D input index
umod r21.x, r20.x, cb1[0].z ; ind MOD physWidth
udiv r21.y, r20.x, cb1[0].z ; ind DIV physWidth
itof r21.xy, r21.xy

itof r21.z, cb1[0].z
sub r21.z, r21.z, r21.1 ; r21.z = physWidth-1

mov r20.yz, r20.00

; if needed process left boundary
ine r20.w, cb1[0].x, r20.0
if_logicalnz r20.w
	
	call 4 ; get next quad with account of boundaries
	mov r0, r30
	iadd r20.y, r20.y, l0.z ; increment input sample counter
	call 4 ; get next quad with account of boundaries
	mov r1, r30
	iadd r20.y, r20.y, l0.z ; increment input sample counter	
	
	call 1 ; compute result
	mov g[r20.x], r22
	iadd r20.x, r20.x, l0.x ; increment output index

	iadd r20.z, r20.z, l0.z ; increment output sample counter
	
	whileloop				
		ige r20.w, r20.z, cb1[0].x ; counter >= hotSpot
		break_logicalnz r20.w
		
		mov r0, r1
		call 4 ; get new quad with account of boundaries
		mov r1, r30
		iadd r20.y, r20.y, l0.z ; increment input sample counter
		call 1 ; compute result
		mov g[r20.x], r22
		iadd r20.x, r20.x, l0.x ; increment output index
		iadd r20.z, r20.z, l0.z ; increment output sample counter
	endloop
		
else	
	call 0
	mov r1, r30
endif

; process 4 quads at once in a loop
udiv r20.z, cb1[0].y, l0.z ; width DIV 4
iadd r20.z, r20.z, l0.w ; (width DIV 4) - 1 - > -1 because 1 quad was already loaded
udiv r20.z, r20.z, l0.z ; ((width DIV 4) - 1) DIV 4 ; number of loops -> NQQ

mov r20.y, r20.0
whileloop	
	ige r20.w, r20.y, r20.z ; ((width DIV 4) - 2) DIV 4
	break_logicalnz r20.w
	
	call 3 ; compute 4 output quads
	iadd r20.y, r20.y, l0.x ; increment loop counter
endloop

; process remaining single quads without boundaries
udiv r20.w, cb1[0].y, l0.z ; width DIV 4
iadd r20.w, r20.w, l0.w ; (width DIV 4) - 1
umul r20.z, r20.z, l0.z ; NQQ*4
imad r20.z, r20.z, l0.w, r20.w ; (width  DIV 4)-(NQQ*4)

mov r20.y, r20.0
whileloop
	ige r20.w, r20.y, r20.z ; (width  DIV 4)-(NQQ*4)
	break_logicalnz r20.w
	
	mov r0, r1	
	call 0
	mov r1, r30
	call 1
	mov g[r20.x], r22
	
	iadd r20.x, r20.x, l0.x ; increment output index
	iadd r20.y, r20.y, l0.x ; increment loop counter
endloop

endmain

; get next input quad and increment input counter, output is stored in r30
func 0	
	; load next quad
	sample_resource(0)_sampler(0) r30, r21.xy
		
	; increment input index
	lt r21.w, r21.x, r21.z
	if_logicalnz r21.w
		add r21.x, r21.x, r21.1
	else
		add r21.0y, r21.y, r21.1
	endif				
ret
endfunc

; function for computing the convolution given r0 and r1, result is stored in r22, uses r23-r25
func 1
	mul r22, r0, cb0[0]
	mad r22, r1, cb0[1], r22

	mul r23, r0, cb0[2]
	mad r23, r1, cb0[3], r23

	mul r24, r0, cb0[4]
	mad r24, r1, cb0[5], r24

	mul r25, r0, cb0[6]
	mad r25, r1, cb0[7], r25
	
	dp4 r22.x, r22, r22.1111
	dp4 r22.y, r23, r23.1111
	dp4 r22.z, r24, r24.1111
	dp4 r22.w, r25, r25.1111
ret
endfunc

; get next 4 input quads and increment input counter, output is stored in r30, r31, r32, r33
func 2
	
	; check physical bound	
	add r30.y, r21.x, l1.x ; x + 4
	lt r30.w, r30.y, r21.z ; x+4 <= physWidth
	if_logicalnz r30.w
		sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r30, r21.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r31, r21.xy
		sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r32, r21.xy
		sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r33, r21.xy		
		
		add r21.x, r21.x, l1.x ; increment index
	else			
		; compute 2D indices for other 3 quads beyond r21.xy
		lt r31.w, r21.x, r21.z
		if_logicalnz r31.w
			add r31.xy, r21.xy, r21.10
		else
			add r31.0y, r21.0y, r21.01
		endif
		
		lt r32.w, r31.x, r21.z
		if_logicalnz r32.w
			add r32.xy, r31.xy, r31.10
		else
			add r32.0y, r31.0y, r31.01
		endif
		
		lt r33.w, r32.x, r21.z
		if_logicalnz r33.w
			add r33.xy, r32.xy, r32.10
		else
			add r33.0y, r32.0y, r32.01
		endif
		
		; do not forget about increment	
		mov r30.xy, r21.xy
				
		lt r33.w, r33.x, r21.z
		if_logicalnz r33.w
			add r21.xy, r33.xy, r33.10
		else
			add r21.0y, r33.0y, r33.01
		endif
		
		sample_resource(0)_sampler(0) r30, r30.xy
		sample_resource(0)_sampler(0) r31, r31.xy
		sample_resource(0)_sampler(0) r32, r32.xy
		sample_resource(0)_sampler(0) r33, r33.xy
	endif			
ret
endfunc

; compute 4 output quads at once, without handling of boundaries
func 3
	call 2 ; load 4 quads at once
	mov r0, r1
	mov r1, r30
	call 1 ; compute result
	mov r34, r22
	
	mov r0, r1
	mov r1, r31
	call 1 ; compute result
	mov r35, r22

	mov r0, r1
	mov r1, r32
	call 1 ; compute result
	mov r36, r22
	
	mov r0, r1
	mov r1, r33
	call 1 ; compute result
	
	; store to result
	mov g[r20.x], r34
	mov g[r20.x+1], r35
	mov g[r20.x+2], r36
	mov g[r20.x+3], r22
ret
endfunc

; get next quad with account of boundaries given index r20.y (curent input sample), returned quad is in r30
func 4
	
	ilt r20.w, r20.y, cb1[0].x ; counter < hotSpot
	if_logicalnz r20.w
		mov r30, r30.0000
	else
		; right boundary
		;;;;;
		
		call 0 ; ordinary load with increment of input index
	endif
ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "Convolve3DX9_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve 3D virtualized array along X (last) direction with up to 9 taps FIR filter
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 12x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[1]	; [hotSpot,width,physWidth,xPitch], [boundary,...]

; hotSpot - has to be aligned to be multiple of 4

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 1, 16, 4, -1
dcl_literal l1, 4.0f, 0.0f, 0.0f, 0.0f
dcl_literal l2, -2, 2, 0, 0

umul r20.x, vaTid.x, cb1[0].w ; iLine*xPitch -> output index in quads

; 2D input index
umod r21.x, r20.x, cb1[0].z ; ind MOD physWidth
udiv r21.y, r20.x, cb1[0].z ; ind DIV physWidth
itof r21.xy, r21.xy

itof r21.z, cb1[0].z
sub r21.z, r21.z, r21.1 ; r21.z = physWidth-1

mov r20.yz, r20.00

; if needed process left boundary
ine r20.w, cb1[0].x, r20.0
if_logicalnz r20.w
	
	call 4 ; get next quad with account of boundaries
	mov r0, r30
	iadd r20.y, r20.y, l0.z ; increment input sample counter
	call 4 ; get next quad with account of boundaries
	mov r1, r30
	iadd r20.y, r20.y, l0.z ; increment input sample counter
	call 4 ; get next quad with account of boundaries
	mov r2, r30
	iadd r20.y, r20.y, l0.z ; increment input sample counter
	
	call 1 ; compute result
	mov g[r20.x], r22
	iadd r20.x, r20.x, l0.x ; increment output index

	iadd r20.z, r20.z, l0.z ; increment output sample counter
	
	whileloop				
		ige r20.w, r20.z, cb1[0].x ; counter >= hotSpot
		break_logicalnz r20.w
		
		mov r0, r1
		mov r1, r2
		call 4 ; get new quad with account of boundaries
		mov r2, r30
		iadd r20.y, r20.y, l0.z ; increment input sample counter
		call 1 ; compute result
		mov g[r20.x], r22
		iadd r20.x, r20.x, l0.x ; increment output index
		iadd r20.z, r20.z, l0.z ; increment output sample counter
	endloop
		
else		
	call 0
	mov r1, r30
	call 0
	mov r2, r30
endif

; process 4 quads at once in a loop
udiv r20.z, cb1[0].y, l0.z ; width DIV 4
iadd r20.z, r20.z, l2.x ; (width DIV 4) - 2 - > -2 because 2 quads were already loaded
udiv r20.z, r20.z, l0.z ; ((width DIV 4) - 2) DIV 4 ; number of loops -> NQQ

mov r20.y, r20.0
whileloop	
	ige r20.w, r20.y, r20.z ; ((width DIV 4) - 2) DIV 4
	break_logicalnz r20.w
	
	call 3 ; compute 4 output quads
	iadd r20.y, r20.y, l0.x ; increment loop counter
endloop

; process remaining single quads without boundaries
udiv r20.w, cb1[0].y, l0.z ; width DIV 4
iadd r20.w, r20.w, l2.x ; (width DIV 4) - 2
umul r20.z, r20.z, l0.z ; NQQ*4
imad r20.z, r20.z, l0.w, r20.w ; (width  DIV 4)-(NQQ*4)

mov r20.y, r20.0
whileloop
	ige r20.w, r20.y, r20.z ; (width  DIV 4)-(NQQ*4)
	break_logicalnz r20.w
	
	mov r0, r1
	mov r1, r2
	call 0
	mov r2, r30
	call 1
	mov g[r20.x], r22
	
	iadd r20.x, r20.x, l0.x ; increment output index
	iadd r20.y, r20.y, l0.x ; increment loop counter
endloop

endmain

; get next input quad and increment input counter, output is stored in r30
func 0	
	; load next quad
	sample_resource(0)_sampler(0) r30, r21.xy
		
	; increment input index
	lt r21.w, r21.x, r21.z
	if_logicalnz r21.w
		add r21.x, r21.x, r21.1
	else
		add r21.0y, r21.y, r21.1
	endif				
ret
endfunc

; function for computing the convolution given r0, r1, r2 result is stored in r22, uses r23-r25
func 1	
	mul r22, r0, cb0[0]
	mad r22, r1, cb0[1], r22
	mad r22, r2, cb0[2], r22

	mul r23, r0, cb0[3]
	mad r23, r1, cb0[4], r23
	mad r23, r2, cb0[5], r23

	mul r24, r0, cb0[6]
	mad r24, r1, cb0[7], r24
	mad r24, r2, cb0[8], r24

	mul r25, r0, cb0[9]
	mad r25, r1, cb0[10], r25
	mad r25, r2, cb0[11], r25
	
	dp4 r22.x, r22, r22.1111
	dp4 r22.y, r23, r23.1111
	dp4 r22.z, r24, r24.1111
	dp4 r22.w, r25, r25.1111
ret
endfunc

; get next 4 input quads and increment input counter, output is stored in r30, r31, r32, r33
func 2
	
	; check physical bound	
	add r30.y, r21.x, l1.x ; x + 4
	lt r30.w, r30.y, r21.z ; x+4 < physWidth
	if_logicalnz r30.w
		sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r30, r21.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r31, r21.xy
		sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r32, r21.xy
		sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r33, r21.xy		
		
		add r21.x, r21.x, l1.x ; increment index
	else			
		; compute 2D indices for other 3 quads beyond r21.xy
		lt r31.w, r21.x, r21.z
		if_logicalnz r31.w
			add r31.xy, r21.xy, r21.10
		else
			add r31.0y, r21.0y, r21.01
		endif
		
		lt r32.w, r31.x, r21.z
		if_logicalnz r32.w
			add r32.xy, r31.xy, r31.10
		else
			add r32.0y, r31.0y, r31.01
		endif
		
		lt r33.w, r32.x, r21.z
		if_logicalnz r33.w
			add r33.xy, r32.xy, r32.10
		else
			add r33.0y, r32.0y, r32.01
		endif
		
		; do not forget about increment	
		mov r30.xy, r21.xy
				
		lt r33.w, r33.x, r21.z
		if_logicalnz r33.w
			add r21.xy, r33.xy, r33.10
		else
			add r21.0y, r33.0y, r33.01
		endif
		
		sample_resource(0)_sampler(0) r30, r30.xy
		sample_resource(0)_sampler(0) r31, r31.xy
		sample_resource(0)_sampler(0) r32, r32.xy
		sample_resource(0)_sampler(0) r33, r33.xy
	endif			
ret
endfunc

; compute 4 output quads at once, without handling of boundaries
func 3
	call 2 ; load 4 quads at once
	mov r0, r1
	mov r1, r2
	mov r2, r30
	call 1 ; compute result
	mov r34, r22
	
	mov r0, r1
	mov r1, r2
	mov r2, r31
	call 1 ; compute result
	mov r35, r22

	mov r0, r1
	mov r1, r2
	mov r2, r32
	call 1 ; compute result
	mov r36, r22
	
	mov r0, r1
	mov r1, r2
	mov r2, r33
	call 1 ; compute result
	
	; store to result
	mov g[r20.x], r34
	mov g[r20.x+1], r35
	mov g[r20.x+2], r36
	mov g[r20.x+3], r22
	
	iadd r20.x, r20.x, l0.z ; increment output index
ret
endfunc

; get next quad with account of boundaries given index r20.y (curent input sample), returned quad is in r30
func 4
	
	ilt r20.w, r20.y, cb1[0].x ; counter < hotSpot
	if_logicalnz r20.w
		mov r30, r30.0000
	else
		; right boundary
		;;;;;
		
		call 0 ; ordinary load with increment of input index
	endif
ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ReshapeVirtToVirt_LI_R">
<![CDATA[
il_ps_2_0
;
;	Reshape a virtualized array to a virtualized array
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 2, 2x4 (LONGINT)
;

dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_cb cb0[2] ; [xPitchSrc,xPitchDst,physWidth,xSizeSrc], [xSizeDst,...]

dcl_literal l0, 4, 1, -1, 0

ftoi r0, vWinCoord0.xy ; 2D output position in quads
umad r0.x, r0.y, cb0[0].z, r0.x ; linear index of current quad in the output
udiv r0.y, r0.x, cb0[0].y ; line number of current quad
umod r1.y, r0.x, cb0[0].y ; position of the quad within the line
umul r0.x, r1.y, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[1].x, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r2, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r2._yzw, r0.xy		
			sample_resource(0)_sampler(0) r2.x___, r0.zw
			mov r2.xyzw, r2.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r2.__zw, r0.xy		
			sample_resource(0)_sampler(0) r2.xy__, r0.zw
			mov r2.xyzw, r2.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r2.___w, r0.xy		
			sample_resource(0)_sampler(0) r2.xyz_, r0.zw
			mov r2.xyzw, r2.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r2.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r2.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r2.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.y
					mov r2._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r2._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.xy00, r2.yz00
					mov r2.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r2._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r2.xyz0, r2.yzw0
					mov r2.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.z
					mov r2._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r2.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.xy00, r2.zw00
					mov r2.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r2.x___, r4.xy
					mov r2.xy0w, r2.zw0x
					mov r2.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.w
					mov r2._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r2.xy__, r4.xy
					mov r2.x0zw, r2.w0xy
					mov r2._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r2.x___, r4.xy
					mov r2.x00w, r2.w00x
					mov r2._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

iadd r1.y, r1.y, l0.y ; increment position of the output quad within the line
ieq r0.z, r1.y, cb0[0].y ; ind+1 = xPitchDst
if_logicalnz r0.z
	
	umod r0.z, cb0[1].x, l0.x ; misalignment xSizeDst MOD 4
	switch r0.z
		case 0 ; no misalignment
			break
		case 1
			mov r2, r2.x000
			break
		case 2
			mov r2, r2.xy00
			break
		case 3
			mov r2, r2.xyz0
			break
	endswitch
	
endif

mov o0, r2

end
]]>
	</ILKernel>
	
<ILKernel name = "ReshapeVirtToSplit8_LI_R">
<![CDATA[
il_ps_2_0
;
;	Reshape a virtualized array to a matrix splitted into 8 parts 
; 
;	inputs: 1
;	outputs: 8
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 2, 2x4 (LONGINT)
;

dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_cb cb0[2] ; [xPitchSrc,xPitchDst,physWidthSrc,xSizeSrc], [xSizeDst,...]
; in this case xPitchDst = physWidthDst

dcl_literal l0, 4, 1, -1, 8

; ************** part 1 **************
; output quad is stored in r2

ftoi r0, vWinCoord0.xy ; 2D output position in quads
mov r1.y, r0.x ; remember position in quads within the row
umul r0.x, r0.x, l0.x ; x in single elements
umul r1.x, r0.y, l0.w ; y*8
umad r0.x, r1.x, cb0[1].x, r0.x ; y*8*xSizeDst + x -> actual linear index in single elements
mov r4.w, r0.x ; remember index value for not to recomputing it again for other matrix parts

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r2, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r2._yzw, r0.xy		
			sample_resource(0)_sampler(0) r2.x___, r0.zw
			mov r2.xyzw, r2.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r2.__zw, r0.xy		
			sample_resource(0)_sampler(0) r2.xy__, r0.zw
			mov r2.xyzw, r2.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r2.___w, r0.xy		
			sample_resource(0)_sampler(0) r2.xyz_, r0.zw
			mov r2.xyzw, r2.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r2.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r2.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r2.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.y
					mov r2._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r2._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.xy00, r2.yz00
					mov r2.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r2._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r2.xyz0, r2.yzw0
					mov r2.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.z
					mov r2._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r2.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.xy00, r2.zw00
					mov r2.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r2.x___, r4.xy
					mov r2.xy0w, r2.zw0x
					mov r2.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.w
					mov r2._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r2.xy__, r4.xy
					mov r2.x0zw, r2.w0xy
					mov r2._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r2.x___, r4.xy
					mov r2.x00w, r2.w00x
					mov r2._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

; ************** part 2 **************
; output quad is stored in r5

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r5, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r5._yzw, r0.xy		
			sample_resource(0)_sampler(0) r5.x___, r0.zw
			mov r5.xyzw, r5.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r5.__zw, r0.xy		
			sample_resource(0)_sampler(0) r5.xy__, r0.zw
			mov r5.xyzw, r5.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r5.___w, r0.xy		
			sample_resource(0)_sampler(0) r5.xyz_, r0.zw
			mov r5.xyzw, r5.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r5.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r5._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r5.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r5.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r5.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r5.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r5._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r5.x, r5.y
					mov r5._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r5._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r5.xy00, r5.yz00
					mov r5.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r5._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r5.xyz0, r5.yzw0
					mov r5.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r5.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r5.x, r5.z
					mov r5._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r5.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r5.xy00, r5.zw00
					mov r5.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r5.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r5.x___, r4.xy
					mov r5.xy0w, r5.zw0x
					mov r5.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r5.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r5.x, r5.w
					mov r5._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r5.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r5.xy__, r4.xy
					mov r5.x0zw, r5.w0xy
					mov r5._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r5.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r5.x___, r4.xy
					mov r5.x00w, r5.w00x
					mov r5._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif


; ************** part 3 **************
; output quad is stored in r6

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r6, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r6._yzw, r0.xy		
			sample_resource(0)_sampler(0) r6.x___, r0.zw
			mov r6.xyzw, r6.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r6.__zw, r0.xy		
			sample_resource(0)_sampler(0) r6.xy__, r0.zw
			mov r6.xyzw, r6.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r6.___w, r0.xy		
			sample_resource(0)_sampler(0) r6.xyz_, r0.zw
			mov r6.xyzw, r6.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r6.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r6._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r6.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r6.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r6.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r6.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r6._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r6.x, r6.y
					mov r6._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r6._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r6.xy00, r6.yz00
					mov r6.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r6._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r6.xyz0, r6.yzw0
					mov r6.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r6.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r6.x, r6.z
					mov r6._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r6.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r6.xy00, r6.zw00
					mov r6.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r6.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r6.x___, r4.xy
					mov r6.xy0w, r6.zw0x
					mov r6.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r6.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r6.x, r6.w
					mov r6._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r6.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r6.xy__, r4.xy
					mov r6.x0zw, r6.w0xy
					mov r6._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r6.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r6.x___, r4.xy
					mov r6.x00w, r6.w00x
					mov r6._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif


; ************** part 4 **************
; output quad is stored in r7

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r7, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r7._yzw, r0.xy		
			sample_resource(0)_sampler(0) r7.x___, r0.zw
			mov r7.xyzw, r7.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r7.__zw, r0.xy		
			sample_resource(0)_sampler(0) r7.xy__, r0.zw
			mov r7.xyzw, r7.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r7.___w, r0.xy		
			sample_resource(0)_sampler(0) r7.xyz_, r0.zw
			mov r7.xyzw, r7.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r7.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r7._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r7.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r7.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r7.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r7.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r7._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r7.x, r7.y
					mov r7._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r7._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r7.xy00, r7.yz00
					mov r7.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r7._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r7.xyz0, r7.yzw0
					mov r7.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r7.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r7.x, r7.z
					mov r7._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r7.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r7.xy00, r7.zw00
					mov r7.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r7.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r7.x___, r4.xy
					mov r7.xy0w, r7.zw0x
					mov r7.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r7.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r7.x, r7.w
					mov r7._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r7.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r7.xy__, r4.xy
					mov r7.x0zw, r7.w0xy
					mov r7._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r7.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r7.x___, r4.xy
					mov r7.x00w, r7.w00x
					mov r7._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

; ************** part 5 **************
; output quad is stored in r8

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r8, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r8._yzw, r0.xy		
			sample_resource(0)_sampler(0) r8.x___, r0.zw
			mov r8.xyzw, r8.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r8.__zw, r0.xy		
			sample_resource(0)_sampler(0) r8.xy__, r0.zw
			mov r8.xyzw, r8.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r8.___w, r0.xy		
			sample_resource(0)_sampler(0) r8.xyz_, r0.zw
			mov r8.xyzw, r8.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r8.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r8._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r8.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r8.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r8.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r8.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r8._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r8.x, r8.y
					mov r8._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r8._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r8.xy00, r8.yz00
					mov r8.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r8._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r8.xyz0, r8.yzw0
					mov r8.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r8.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r8.x, r8.z
					mov r8._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r8.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r8.xy00, r8.zw00
					mov r8.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r8.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r8.x___, r4.xy
					mov r8.xy0w, r8.zw0x
					mov r8.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r8.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r8.x, r8.w
					mov r8._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r8.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r8.xy__, r4.xy
					mov r8.x0zw, r8.w0xy
					mov r8._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r8.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r8.x___, r4.xy
					mov r8.x00w, r8.w00x
					mov r8._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

; ************** part 6 **************
; output quad is stored in r9

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r9, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r9._yzw, r0.xy		
			sample_resource(0)_sampler(0) r9.x___, r0.zw
			mov r9.xyzw, r9.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r9.__zw, r0.xy		
			sample_resource(0)_sampler(0) r9.xy__, r0.zw
			mov r9.xyzw, r9.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r9.___w, r0.xy		
			sample_resource(0)_sampler(0) r9.xyz_, r0.zw
			mov r9.xyzw, r9.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r9.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r9._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r9.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r9.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r9.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r9.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r9._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r9.x, r9.y
					mov r9._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r9._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r9.xy00, r9.yz00
					mov r9.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r9._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r9.xyz0, r9.yzw0
					mov r9.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r9.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r9.x, r9.z
					mov r9._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r9.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r9.xy00, r9.zw00
					mov r9.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r9.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r9.x___, r4.xy
					mov r9.xy0w, r9.zw0x
					mov r9.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r9.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r9.x, r9.w
					mov r9._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r9.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r9.xy__, r4.xy
					mov r9.x0zw, r9.w0xy
					mov r9._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r9.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r9.x___, r4.xy
					mov r9.x00w, r9.w00x
					mov r9._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

; ************** part 7 **************
; output quad is stored in r10

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r10, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r10._yzw, r0.xy		
			sample_resource(0)_sampler(0) r10.x___, r0.zw
			mov r10.xyzw, r10.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r10.__zw, r0.xy		
			sample_resource(0)_sampler(0) r10.xy__, r0.zw
			mov r10.xyzw, r10.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r10.___w, r0.xy		
			sample_resource(0)_sampler(0) r10.xyz_, r0.zw
			mov r10.xyzw, r10.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r10.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r10._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r10.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r10.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r10.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r10.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r10._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r10.x, r10.y
					mov r10._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r10._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r10.xy00, r10.yz00
					mov r10.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r10._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r10.xyz0, r10.yzw0
					mov r10.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r10.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r10.x, r10.z
					mov r10._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r10.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r10.xy00, r10.zw00
					mov r10.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r10.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r10.x___, r4.xy
					mov r10.xy0w, r10.zw0x
					mov r10.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r10.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r10.x, r10.w
					mov r10._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r10.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r10.xy__, r4.xy
					mov r10.x0zw, r10.w0xy
					mov r10._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r10.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r10.x___, r4.xy
					mov r10.x00w, r10.w00x
					mov r10._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

; ************** part 8 **************
; output quad is stored in r11

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r11, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r11._yzw, r0.xy		
			sample_resource(0)_sampler(0) r11.x___, r0.zw
			mov r11.xyzw, r11.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r11.__zw, r0.xy		
			sample_resource(0)_sampler(0) r11.xy__, r0.zw
			mov r11.xyzw, r11.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r11.___w, r0.xy		
			sample_resource(0)_sampler(0) r11.xyz_, r0.zw
			mov r11.xyzw, r11.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r11.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r11._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r11.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r11.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r11.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r11.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r11._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r11.x, r11.y
					mov r11._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r11._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r11.xy00, r11.yz00
					mov r11.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r11._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r11.xyz0, r11.yzw0
					mov r11.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r11.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r11.x, r11.z
					mov r11._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r11.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r11.xy00, r11.zw00
					mov r11.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r11.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r11.x___, r4.xy
					mov r11.xy0w, r11.zw0x
					mov r11.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r11.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r11.x, r11.w
					mov r11._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r11.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r11.xy__, r4.xy
					mov r11.x0zw, r11.w0xy
					mov r11._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r11.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r11.x___, r4.xy
					mov r11.x00w, r11.w00x
					mov r11._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

iadd r1.y, r1.y, l0.y ; increment position of the output quad within the row
ieq r0.z, r1.y, cb0[0].y ; ind+1 = xPitchDst
if_logicalnz r0.z
	
	umod r0.z, cb0[1].x, l0.x ; misalignment xSizeDst MOD 4
	switch r0.z
		case 0 ; no misalignment
			break
		case 1
			mov r2, r2.x000
			mov r5, r5.x000
			mov r6, r6.x000
			mov r7, r7.x000
			mov r8, r8.x000
			mov r9, r9.x000
			mov r10, r10.x000
			mov r11, r11.x000
			break
		case 2
			mov r2, r2.xy00
			mov r5, r5.xy00
			mov r6, r6.xy00
			mov r7, r7.xy00
			mov r8, r8.xy00
			mov r9, r9.xy00
			mov r10, r10.xy00
			mov r11, r11.xy00
			break
		case 3
			mov r2, r2.xyz0
			mov r5, r5.xyz0
			mov r6, r6.xyz0
			mov r7, r7.xyz0
			mov r8, r8.xyz0
			mov r9, r9.xyz0
			mov r10, r10.xyz0
			mov r11, r11.xyz0
			break
	endswitch
	
endif

mov o0, r2
mov o1, r5
mov o2, r6
mov o3, r7
mov o4, r8
mov o5, r9
mov o6, r10
mov o7, r11
	
end
]]>
	</ILKernel>
	
<ILKernel name = "ReshapeSplit8ToVirt_LI_R">
<![CDATA[
il_ps_2_0
;
;	Reshape a matrix splitted into 8 parts to a virtualized array
; 
;	inputs: 8
;	outputs: 1
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 2, 2x4 (LONGINT)
;


end
]]>
	</ILKernel>
		
	
<ILKernel name = "Transpose3D0_LI_R">
<![CDATA[
il_ps_2_0
;
;	Transpose a virtualized 3D array
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 4x4 (LONGINT) [physWidth, newNy*newNx, newNx, 1], [tZ, tY, tX, 0], [oldNy*oldNx, oldNx, 1, 0],
;										[xPitchSrc,xPitchDst,xSizeSrc,xSizeDst]
;
dcl_cb cb0[4]
dcl_output_generic o0
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0, 0

ftoi r0, vWinCoord0.xy ; 2D output position in quads
umad r0.x, r0.y, cb0[0].x, r0.x ; linear index of current quad in the output
udiv r0.y, r0.x, cb0[3].y ; line number of current quad
umod r1.y, r0.x, cb0[3].y ; position of the quad within the line
umul r0.x, r1.y, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[3].w, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

call 0
mov r4.x, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.y, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.z, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.w, r1.x

mov o0, r4

endmain

; get input array element in given output index r0.x in single components, returned value is in r1.x
func 0
	
; compute z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; z := ind/(newNy*newNx)
umod r1.z, r0.x, cb0[0].y	; r1.z := ind - z*newNy*newNx
udiv r1.y, r1.z, cb0[0].z	; y := (ind - z*newNy*newNx)/newNx
umod r1.z, r1.z, cb0[0].z	; x := ind - z*newNy*newNx - y*newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

endswitch

; compute linear index in the input
imul r2.xyz, r2.xyz, cb0[2].xyz	; [z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z

; compute corresponding 2D index in the input
udiv r1.y, r2.x, cb0[3].z ; ind DIV xSizeSrc -> line number in the input
umod r1.x, r2.x, cb0[3].z ; single element position within the line
umul r1.z, cb0[3].x, l0.x ; xPitchSrc*4
umad r1.x, r1.y, r1.z, r1.x ; single element position with account of input's padding

umod r1.y, r1.x, l0.x ; 4 components misalignment
udiv r1.x, r1.x, l0.x ; linear index in quads

; compute 2D position in quads
udiv r3.y, r1.x, cb0[0].x
umod r3.x, r1.x, cb0[0].x
itof r3.xy, r3.xy

switch r1.y

	case 0
		sample_resource(0)_sampler(0) r1.x___, r3.xy
	break
	
	case 1
		sample_resource(0)_sampler(0) r1._y__, r3.xy
		mov r1.x, r1.y
	break
	
	case 2
		sample_resource(0)_sampler(0) r1.__z_, r3.xy
		mov r1.x, r1.z
	break
	
	case 3
		sample_resource(0)_sampler(0) r1.___w, r3.xy
		mov r1.x, r1.w
	break
	
endswitch
	
ret
endfunc

end
]]>
	</ILKernel>
	

<ILKernel name = "Transpose4D_LI_R">
<![CDATA[
il_ps_2_0
;
;	Transpose a virtualized 4D array
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 1, 4x4 (LONGINT) [physWidth, newNz*newNy*newNx, newNy*newNx, newNx], 
;											[tT, tZ, tY, tX], [oldNz*oldNy*oldNx, oldNy*oldNx, oldNx, 1], [xPitchSrc,xPitchDst,xSizeSrc,xSizeDst]
dcl_cb cb0[4]
dcl_output_generic o0
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0, 0

ftoi r0, vWinCoord0.xy ; 2D output position in quads
umad r0.x, r0.y, cb0[0].x, r0.x ; linear index of current quad in the output
udiv r0.y, r0.x, cb0[3].y ; line number of current quad
umod r1.y, r0.x, cb0[3].y ; position of the quad within the line
umul r0.x, r1.y, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[3].w, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

call 0
mov r4.x, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.y, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.z, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.w, r1.x

mov o0, r4

endmain

; get input array element in given output index r0.x in single components, returned value is in r1.x
func 0
	
; compute t, z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; t := ind/(newNz*newNy*newNx)
umod r1.w, r0.x, cb0[0].y	; r1.w := ind - t*newNz*newNy*newNx
udiv r1.y, r1.w, cb0[0].z	; z := (ind - t*newNz*newNy*newNx)/(newNy*newNx)
umod r1.w, r1.w, cb0[0].z	; r1.w := ind - t*newNz*newNy*newNx - z*(newNy*newNx)
udiv r1.z, r1.w, cb0[0].w	; y := (ind - t*newNz*newNy*newNx - z*(newNy*newNx))/newNx
umod r1.w, r1.w, cb0[0].w	; x := (ind - t*newNz*newNy*newNx - z*(newNy*newNx)) MOD newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break
	
	case 3
		mov r2.w, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

	case 3
		mov r2.w, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

	case 3
		mov r2.w, r1.z
	break

endswitch

switch cb0[1].w

	default
		mov r2.x, r1.w
	break

	case 1
		mov r2.y, r1.w
	break

	case 2
		mov r2.z, r1.w
	break

	case 3
		mov r2.w, r1.w
	break

endswitch

; compute linear index in the input
imul r2.xyzw, r2.xyzw, cb0[2].xyzw	; [t*oldNz*oldNy*oldNx, z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z
iadd r2.x, r2.x, r2.w

; compute corresponding 2D index in the input
udiv r1.y, r2.x, cb0[3].z ; ind DIV xSizeSrc -> line number in the input
umod r1.x, r2.x, cb0[3].z ; single element position within the line
umul r1.z, cb0[3].x, l0.x ; xPitchSrc*4
umad r1.x, r1.y, r1.z, r1.x ; single element position with account of input's padding

umod r1.y, r1.x, l0.x ; 4 components misalignment
udiv r1.x, r1.x, l0.x ; linear index in quads

; compute 2D position in quads
udiv r3.y, r1.x, cb0[0].x
umod r3.x, r1.x, cb0[0].x
itof r3.xy, r3.xy

switch r1.y

	case 0
		sample_resource(0)_sampler(0) r1.x___, r3.xy
	break
	
	case 1
		sample_resource(0)_sampler(0) r1._y__, r3.xy
		mov r1.x, r1.y
	break
	
	case 2
		sample_resource(0)_sampler(0) r1.__z_, r3.xy
		mov r1.x, r1.z
	break
	
	case 3
		sample_resource(0)_sampler(0) r1.___w, r3.xy
		mov r1.x, r1.w
	break
	
endswitch
	
ret
endfunc

end
]]>
	</ILKernel>	
	
<ILKernel name = "Transpose3D_LI_R">
<![CDATA[
il_ps_2_0
;
;	Transpose a virtualized 3D array
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 4x4 (LONGINT) [physWidth, newNy*newNx, newNx, 1], [tZ, tY, tX, 0], [oldNy*oldNx, oldNx, 1, 0],
;										[xPitchSrc,xPitchDst,xSizeSrc,xSizeDst]
;
dcl_cb cb0[4]
dcl_output_generic o0
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0, 0

ftoi r0, vWinCoord0.xy ; 2D output position in quads
umad r0.x, r0.y, cb0[0].x, r0.x ; linear index of current quad in the output
udiv r0.y, r0.x, cb0[3].y ; line number of current quad
umod r1.y, r0.x, cb0[3].y ; position of the quad within the line
umul r0.x, r1.y, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[3].w, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

call 0
mov r4.xyz, r1.xyz

iadd r0.x, r0.x, l0.y
call 0
mov r5.xyz, r1.xyz

iadd r0.x, r0.x, l0.y
call 0
mov r6.xyz, r1.xyz

iadd r0.x, r0.x, l0.y
call 0
mov r7.xyz, r1.xyz

ieq r1.xy, r4.xy, r5.xy
ieq r2.xy, r5.xy, r6.xy
ieq r3.xy, r6.xy, r7.xy

iand r1.xy, r1.xy, r2.xy
iand r1.xy, r1.xy, r3.xy
iand r1.x, r1.x, r1.y
if_logicalnz r1.x
	itof r4.xy, r4.xy
	;sample_resource(0)_sampler(0) o0, r4.xy
	mov o0, r4.0000
else
	mov r0.xyz, r4.xyz
	call 1
	mov r4.x, r1.x
	
	mov r0.xyz, r5.xyz
	call 1
	mov r4.y, r1.x
	
	mov r0.xyz, r6.xyz
	call 1
	mov r4.z, r1.x
	
	mov r0.xyz, r7.xyz
	call 1
	mov r4.w, r1.x
	
	mov o0, r4
endif

;call 0
;mov r4.x, r1.x
;
;iadd r0.x, r0.x, l0.y
;call 0
;mov r4.y, r1.x
;
;iadd r0.x, r0.x, l0.y
;call 0
;mov r4.z, r1.x
;
;iadd r0.x, r0.x, l0.y
;call 0
;mov r4.w, r1.x
;
;mov o0, r4

endmain

; given output index r0.x in single components, get corresponding 2D input quad position in r1.xy and misalignment in r1.z
func 0
	
; compute z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; z := ind/(newNy*newNx)
umod r1.z, r0.x, cb0[0].y	; r1.z := ind - z*newNy*newNx
udiv r1.y, r1.z, cb0[0].z	; y := (ind - z*newNy*newNx)/newNx
umod r1.z, r1.z, cb0[0].z	; x := ind - z*newNy*newNx - y*newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

endswitch

; compute linear index in the input
imul r2.xyz, r2.xyz, cb0[2].xyz	; [z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z

; compute corresponding 2D index in the input
udiv r1.y, r2.x, cb0[3].z ; ind DIV xSizeSrc -> line number in the input
umod r1.x, r2.x, cb0[3].z ; single element position within the line
umul r1.z, cb0[3].x, l0.x ; xPitchSrc*4
umad r1.x, r1.y, r1.z, r1.x ; single element position with account of input's padding

umod r1.z, r1.x, l0.x ; 4 components misalignment
udiv r1.x, r1.x, l0.x ; linear index in quads

; compute 2D position in quads
udiv r1.y, r1.x, cb0[0].x
umod r1.x, r1.x, cb0[0].x
	
ret
endfunc

; get a single element given its 2D quad position in r0.xy (integer) and misalignment in r0.z (integer)
func 1

itof r0.xy, r0.xy

switch r0.z

	case 0
		sample_resource(0)_sampler(0) r1.x___, r0.xy
	break
	
	case 1
		sample_resource(0)_sampler(0) r1._y__, r0.xy
		mov r1.x, r1.y
	break
	
	case 2
		sample_resource(0)_sampler(0) r1.__z_, r0.xy
		mov r1.x, r1.z
	break
	
	case 3
		sample_resource(0)_sampler(0) r1.___w, r0.xy
		mov r1.x, r1.w
	break
	
endswitch

ret
endfunc

end
]]>
	</ILKernel>	
	
</Kernels>