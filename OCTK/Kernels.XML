<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>

<Kernels>
	
	<ILKernel name = "SubCopy2DAligned_LI_R_LR">		
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when arrays are non virtualized and copy regions are aligned to
;	nComponents (srcOrigin[1] MOD nComponents = 0) & (dstOrigin[1] MOD nComponents = 0) & (size[1] MOD nComponents) = 0)
;	for both input and output
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: any
;	constants: 1 (REAL) : [(srcOrigin[1]-dstOrigin[1]) DIV nComponents,srcOrigin[0]-dstOrigin[0],...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

add r0.xy, vWinCoord0.xy, cb0[0].xy	; compute position in the input
sample_resource(0)_sampler(0) r1, r0
mov o0, r1
end
]]>
	</ILKernel>
	
	<ILKernel name = "SubCopy2DUnaligned_LI_R_4">
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when arrays are non virtualized and copy regions are not aligned to
;	nComponents (srcOrigin[1] MOD nComponents # 0) OR (dstOrigin[1] MOD nComponents # 0) OR (subSize[1] MOD nComponents) # 0)
; 
;	inputs: 2 (src,dst)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 (same for input and output)
;	constants: 1,  2 x 4 (LONGINT) : [srcOrigin[1],srcOrigin[0],dstOrigin[1],dstOrigin[0]];  [subSize[1],subSize[0],dstOrigin[1] DIV 4,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[2]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, -1, -1, 0

ftoi r0.xy, vWinCoord0.xy ; convert output position in multi-component elements  to integers
mov r0.z, r0.x ; r0.z := Int(vWinCoord0.x)

; output position in single-component elements
umul r0.x, r0.x, l0.x ; x*4

; account unaligned dstOrigin[1]
ieq r4.x, r0.z, cb0[1].z ; Int(vWinCoord0.x) = dstOrigin[1] DIV 4
if_logicalnz r4.x
	umod r4.x, cb0[0].z, l0.x ; dstOrigin[1] MOD 4
	iadd r0.x, r0.x, r4.x
endif

; input position in single-component elements
umad r1.xy, cb0[0].zw, l0.yz, cb0[0].xy ; [srcOrigin[1],srcOrigin[0]] - [dstOrigin[1],dstOrigin[0]]
iadd r1.xy, r0.xy, r1.xy

umod r4.x, r1.x, l0.x ; input.x MOD 4
udiv r1.x, r1.x, l0.x ; input position in multi-component elements
itof r1.xy, r1.xy

switch r4.x
	
	case 0
		sample_resource(0)_sampler(0) r3.xyzw, r1.xy
	break
		
	case 1		
		sample_resource(0)_sampler(0) r3._yzw, r1.xy		
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.x___, r1.xy
		mov r3.xyzw, r3.yzwx
	break
	
	case 2
		sample_resource(0)_sampler(0) r3.__zw, r1.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.xy__, r1.xy		
		mov r3.xyzw, r3.zwxy
	break
	
	case 3
		sample_resource(0)_sampler(0) r3.___w, r1.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.xyz_, r1.xy
		mov r3.xyzw, r3.wxyz
	break
endswitch

; write to the output

iadd r4.x, cb0[0].z, cb0[1].x ; dstOrigin[1] + subSize[1]	
iadd r4.x, r4.x, l0.y ; dstOrigin[1] + subSize[1] - 1 ; right dst bound in single-component elements	
udiv r4.y, r4.x, l0.x ; (dstOrigin[1] + subSize[1] - 1) DIV 4 ; right dst bound in multi-component elements

ine r4.z, r0.z, cb0[1].z ; output.x # (dstOrigin[1] DIV 4) -> not the left dst bound
if_logicalnz r4.z		
	
	ine r4.z, r0.z, r4.y ; Int(vWinCoord0.x) # (dstOrigin[1] + subSize[1] - 1) DIV 4 -> not the right dst bound
	if_logicalnz r4.z
		mov o0.xyzw, r3.xyzw
	else
		
		umod r4.z, r4.x, l0.x ; (dstOrigin[1] + subSize[1] - 1) MOD 4
		
		switch r4.z
			
			case 0
				sample_resource(1)_sampler(1) r3._yzw, vWinCoord0.xy
				mov o0, r3
			break
			
			case 1
				sample_resource(1)_sampler(1) r3.__zw, vWinCoord0.xy
				mov o0, r3
			break
			
			case 2
				sample_resource(1)_sampler(1) r3.___w, vWinCoord0.xy
				mov o0, r3
			break
			
			case 3
				mov o0, r3
			break
		endswitch
		
	endif	
	
else ; the left dst bound

	ine r4.z, r0.z, r4.y ; Int(vWinCoord0.x) # (dstOrigin[1] + subSize[1] - 1) DIV 4 -> not the right dst bound
	if_logicalnz r4.z
			
		umod r4.z, cb0[0].z, l0.x ; dstOrigin[1] MOD 4
		
		switch r4.z						
		
			case 0
				mov o0, r3
			break
			
			case 1
				mov r3.0yzw, r3.0xyz
				sample_resource(1)_sampler(1) r3.x___, vWinCoord0.xy
				mov o0, r3
			break
			
			case 2
				mov r3.00zw, r3.00xy
				sample_resource(1)_sampler(1) r3.xy__, vWinCoord0.xy
				mov o0, r3
			break
			
			case 3
				mov r3.000w, r3.000x
				sample_resource(1)_sampler(1) r3.xyz_, vWinCoord0.xy
				mov o0, r3
			break
									
		endswitch				
			
	else ; very specific case when subSize[1] <= nComponents			
	
		umod r4.x, cb0[0].z, l0.x; dstOrigin[1] MOD 4		
		
		switch r4.x
			
			case 0				
				switch cb0[1].x ; subSize[1]
				
					case 1
						sample_resource(1)_sampler(1) r3._yzw, vWinCoord0.xy
						mov o0, r3
					break
					
					case 2
						sample_resource(1)_sampler(1) r3.__zw, vWinCoord0.xy
					mov o0, r3
					break
					
					case 3
						sample_resource(1)_sampler(1) r3.___w, vWinCoord0.xy
						mov o0, r3
					break
					
					case 4
						mov o0, r3
					break
										
				endswitch;
			break
			
			case 1
				switch cb0[1].x ; subSize[1]
					case 1
						mov r3.y, r3.x
						sample_resource(1)_sampler(1) r3.x_zw, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 2
						mov r3.0yz0, r3.0xy0
						sample_resource(1)_sampler(1) r3.x__w, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 3
						mov r3.0yzw, r3.0xyz
						sample_resource(1)_sampler(1) r3.x___, vWinCoord0.xy	
						mov o0, r3
					break										
				endswitch;
			break
			
			case 2
				switch cb0[1].x ; subSize[1]
					case 1
						mov r3.z, r3.x
						sample_resource(1)_sampler(1) r3.xy_w, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 2
						mov r3.00zw, r3.00xy
						sample_resource(1)_sampler(1) r3.xy__, vWinCoord0.xy
						mov o0, r3
					break										
				endswitch;
			break
			
			case 3				
				mov r3.w, r3.x
				sample_resource(1)_sampler(1) r3.xyz_, vWinCoord0.xy
				mov o0, r3
			break
		endswitch				
		
	endif

endif								

end				
]]>	
	</ILKernel>
	
	<ILKernel name = "SubCopy2DNonVirtToVirt_LI_R_4">					
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when source array is not virtualized and destination is virtualized
; 
;	inputs: 1 (src)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 - for the input, 1 - for the output (virtualized)
;	constants: 1, 2x4 (LONGINT) : [srcOrigin[1]-dstOrigin[1],srcOrigin[0]-dstOrigin[0],dst.Width,dst.physWidth]; [dstOrigin[1],dstOrigin[0],dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[2]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, 0, 0, 0

; compute linear index in the output
ftoi r0.xy, vWinCoord0.xy
umad r0.x, r0.y, cb0[0].w, r0.x ; ind := y*dst.physWidth + x

; compute non-virtual position in the output
udiv r0.y, r0.x, cb0[0].z ; y := ind DIV dst.Width
umod r0.x, r0.x, cb0[0].z

ilt r1.xy, r0.xy, cb0[1].xy ; [x,y] < [dstOrigin[1],dstOrigin[0]]
inot r1.xy, r1.xy ;  ~([x,y] < [dstOrigin[1],dstOrigin[0]]) -> [x,y] >= [dstOrigin[1],dstOrigin[0]]
ilt r2.xy, r0.xy, cb0[1].zw ; [x,y] < [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
and r1.xy, r1.xy, r2.xy
ieq r2.xy, r0.xy, cb0[1].zw ; [x,y] = [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
ior r1.xy, r1.xy, r2.xy ; ([x,y] >= [dstOrigin[1],dstOrigin[0]]) & ([x,y] <= [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1])

and r1.x, r1.x, r1.y
if_logicalnz r1.x

	; compute 2D position in the input, in single-component elements
	iadd r0.xy, r0.xy, cb0[0].xy

	umod r0.z, r0.x, l0.x ; x MOD 4

	udiv r0.x, r0.x, l0.x ; input position in multi-component elements
	itof r0.xy, r0.xy ; convert [x,y] to floats

	switch r0.z
		
		case 0
			sample_resource(0)_sampler(0) o0.x, r0.xy
		break
		
		case 1
			sample_resource(0)_sampler(0) r1._y__, r0.xy
			mov o0.x, r1.y
		break
		
		case 2
			sample_resource(0)_sampler(0) r1.__z_, r0.xy
			mov o0.x, r1.z
		break
	
		case 3
			sample_resource(0)_sampler(0) r1.___w, r0.xy
			mov o0.x, r1.w
		break
	endswitch	

else
	sample_resource(1)_sampler(1) o0.x, vWinCoord0.xy	
endif

end				
]]>	
	</ILKernel>
	
	<ILKernel name = "SubCopy2DVirtToNonVirtAligned_LI_R_4">	
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when source array is virtualized, destination is not virtualized, and copy regions are aligned to
;	nComponents (dstOrigin[1] MOD nComponents = 0) & (subSize[1] MOD nComponents) = 0)
; 
;	inputs: 1 (src)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 - for the output, 1 - for the input (virtualized)
;	constants: 1 (LONGINT) : [srcOrigin[1]-dstOrigin[1],srcOrigin[0]-dstOrigin[0],src.Width,src.physWidth]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, -1, 0, 0

; compute non-virtual position in the input
ftoi r0.xy, vWinCoord0.xy
umul r0.x, r0.x, l0.x ; output position in single-component elements
iadd r0.xy, r0.xy, cb0[0].xy ; input position in single-component elements

; compute linear index in the input
umad r1.x, r0.y, cb0[0].z, r0.x ; ind := y*src.Width + x

; compute 2D virtual position in the input
udiv r1.y, r1.x, cb0[0].w ; y := ind DIV src.physWidth
umod r1.x, r1.x, cb0[0].w ; x := ind MOD src.physWidth

umad r4.x, r1.x, l0.y, cb0[0].w ; r4.x := src.physWidth - x

itof r1.xy, r1.xy

ige r4.z, r4.x, l0.x ; src.physWidth - x >= 4
if_logicalnz r4.z		
	
	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) o0.x, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) o0.y, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) o0.z, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) o0.w, r1.xy
		
else
	
	itof r5.x, cb0[0].w
	
	add r2.xy, r1.xy, r1.10
	ge r5.z, r2.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r2.0y, r2.y, r2.1 ; INC(y)
	endif
	
	add r3.xy, r2.xy, r2.10
	ge r5.z, r3.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r3.0y, r3.y, r3.1 ; INC(y)
	endif
	
	add r4.xy, r3.xy, r3.10
	ge r5.z, r4.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r4.0y, r4.y, r4.1 ; INC(y)
	endif
	
	sample_resource(0)_sampler(0) o0.x, r1.xy
	sample_resource(0)_sampler(0) o0.y, r2.xy
	sample_resource(0)_sampler(0) o0.z, r3.xy
	sample_resource(0)_sampler(0) o0.w, r4.xy
		
endif

end
]]>	
	</ILKernel>
	
	<ILKernel name = "ClearMemory">
<![CDATA[
il_ps_2_0
;
;	Clear GPU memory resource
; 
;	inputs: 0
;	outputs: 1
;	data type: any
;	nComponents: any
;	constants: 0
;
dcl_output_generic o0
mov r0, r0.0000
mov o0, r0
end
]]>						
	</ILKernel>
	
	<ILKernel name = "Add_R">
<![CDATA[
il_ps_2_0
;
;	Array addition
; 
;	inputs: 2
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
add o0, r0, r1
end		
]]>
	</ILKernel>
	
	<ILKernel name = "AddScalar_R">
<![CDATA[
il_ps_2_0
;
;	Array + Scalar
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
add o0, r0, cb0[0]
end		
]]>
	</ILKernel>
	
	<ILKernel name = "Sub_R">
<![CDATA[
il_ps_2_0
;
;	Array subtraction
; 
;	inputs: 2
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sub o0, r0, r1
end		
]]>
	</ILKernel>
		
	<ILKernel name = "ScalarSub_R">
<![CDATA[
il_ps_2_0
;
;	Scalar - Array
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sub o0, cb0[0], r0
end		
]]>
	</ILKernel>
	
	<ILKernel name = "EwMul_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
mul o0, r0, r1
end
]]>
	</ILKernel>
	
	<ILKernel name = "MulByScalar_R">
<![CDATA[
il_ps_2_0
;
;	Array * Scalar
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
mul o0, r0, cb0[0]
end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwDiv_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication
; 
;	inputs: 2
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
div_zeroop(inf_else_max) o0, r0, r1
end
]]>
	</ILKernel>
	
	<ILKernel name = "DivByScalar_R">
<![CDATA[
il_ps_2_0
;
;	Array / Scalar
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
div_zeroop(inf_else_max) o0, r0, cb0[0]
end		
]]>
	</ILKernel>	
	
	<ILKernel name = "ScalarEwDiv_R">
<![CDATA[
il_ps_2_0
;
;	Scalar ./ Array
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
div_zeroop(inf_else_max) o0, cb0[0], r0
end		
]]>
	</ILKernel>
	
	<ILKernel name = "AddSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Addition of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

add o0, r0, r8
add o1, r1, r9
add o2, r2, r10
add o3, r3, r11
add o4, r4, r12
add o5, r5, r13
add o6, r6, r14
add o7, r7, r15

end		
]]>
	</ILKernel>		
	
	<ILKernel name = "SubSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Subtraction of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

sub o0, r0, r8
sub o1, r1, r9
sub o2, r2, r10
sub o3, r3, r11
sub o4, r4, r12
sub o5, r5, r13
sub o6, r6, r14
sub o7, r7, r15

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwMulSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

mul o0, r0, r8
mul o1, r1, r9
mul o2, r2, r10
mul o3, r3, r11
mul o4, r4, r12
mul o5, r5, r13
mul o6, r6, r14
mul o7, r7, r15

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwDivSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise division of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

div_zeroop(inf_else_max) o0, r0, r8
div_zeroop(inf_else_max) o1, r1, r9
div_zeroop(inf_else_max) o2, r2, r10
div_zeroop(inf_else_max) o3, r3, r11
div_zeroop(inf_else_max) o4, r4, r12
div_zeroop(inf_else_max) o5, r5, r13
div_zeroop(inf_else_max) o6, r6, r14
div_zeroop(inf_else_max) o7, r7, r15

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "AddSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Addition of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

add o0, r0, r4
add o1, r1, r5
add o2, r2, r6
add o3, r3, r7

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "SubSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Subtraction of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)


sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sub o0, r0, r4
sub o1, r1, r5
sub o2, r2, r6
sub o3, r3, r7

end		
]]>
	</ILKernel>		
	
	<ILKernel name = "EwMulSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

mul o0, r0, r4
mul o1, r1, r5
mul o2, r2, r6
mul o3, r3, r7

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwDivSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise division of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

div_zeroop(inf_else_max) o0, r0, r4
div_zeroop(inf_else_max) o1, r1, r5
div_zeroop(inf_else_max) o2, r2, r6
div_zeroop(inf_else_max) o3, r3, r7

end		
]]>
	</ILKernel>
	
	<ILKernel name = "MatMulSplitted8_R">		
<![CDATA[
il_ps_2_0
;
;	Multiplication of matrices splitted into 8 parts: C := A*B
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_cb cb0[1]	; [A.physWidth,...]

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

; parts of A
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

; parts of B
dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; initialize sample counters of A
mov r0.0y, vWinCoord0.y		; r0 := [0,y]
sub r0.x, r0.x, r0.1				; account first increment

; initialize sample counter of B
mov r1.x0, vWinCoord0.x		; [x,0]
sub r1.y, r1.y, l0.y				; account first increment

; clear float4 accumulators for 8x4 * 4x4 matrix multiply result
mov r34, r34.0000	
mov r35, r35.0000
mov r36, r36.0000
mov r37, r37.0000
mov r38, r38.0000	
mov r39, r39.0000
mov r40, r40.0000
mov r41, r41.0000

mov r2.0y00, cb0[0].x			; r2.x is the loop counter, r2.y := A.width
sub r2.x, r2.x, r2.1				; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, l0.y

	; increment sample counter of A
	add r0.x, r0.x, r0.1

	add r2.x, r2.x, r2.1	; loop counter ++

   	ge r2.z, r2.x, r2.y	; while(loop counter < A.physWidth)
   	break_logicalnz r2.z

	; load next 4x4 block of B

	mod r3.x, r2.x, l0.x	; r3.x := r2.x % 2

	eq r3.y, r3.x, r3.0
	if_logicalnz r3.y	; if r3.x == 0
		sample_resource(8)_sampler(8) r10, r1.xy00
		sample_resource(9)_sampler(9) r11, r1.xy00
		sample_resource(10)_sampler(10) r12, r1.xy00
		sample_resource(11)_sampler(11) r13, r1.xy00
	else
		sample_resource(12)_sampler(12) r10, r1.xy00
		sample_resource(13)_sampler(13) r11, r1.xy00
		sample_resource(14)_sampler(14) r12, r1.xy00
		sample_resource(15)_sampler(15) r13, r1.xy00
	endif

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xy00
	sample_resource(1)_sampler(1) r27, r0.xy00
	sample_resource(2)_sampler(2) r28, r0.xy00
	sample_resource(3)_sampler(3) r29, r0.xy00
	sample_resource(4)_sampler(4) r30, r0.xy00
	sample_resource(5)_sampler(5) r31, r0.xy00
	sample_resource(6)_sampler(6) r32, r0.xy00
	sample_resource(7)_sampler(7) r33, r0.xy00

	; compute Ablk * Bblk

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

endloop

; store the result
mov o0, r34
mov o1, r35
mov o2, r36
mov o3, r37
mov o4, r38
mov o5, r39
mov o6, r40
mov o7, r41

end
]]>
	</ILKernel>
	
	<ILKernel name = "MatMulSplitted8Unroll2_R">		
<![CDATA[
il_ps_2_0
;
;	Multiplication of matrices splitted into 8 parts: C := A*B
; 	use loop unrolling by 2
;
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_cb cb0[1]	; [A.physWidth,...]

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; initialize sample counters of A
mov r0.01z0, vWinCoord0.00y0		; r0 := [0,1,y,0]
sub r0.xy, r0.xy, l0.xx					; account first increment

; initialize sample counter of B
mov r1.x0, vWinCoord0.x			; [x,0,1,...]
sub r1.y, r1.y, r1.1					; account first increment

; clear float4 accumulators for 8x4 * 4x4 matrix multiply result
mov r34, r34.0000	
mov r35, r35.0000
mov r36, r36.0000
mov r37, r37.0000
mov r38, r38.0000	
mov r39, r39.0000
mov r40, r40.0000
mov r41, r41.0000

mul r2.0y, l0.y, cb0[0].x	; r2.x is the loop counter, r2.y := floor(A.physWidth/2)
flr r2.y, r2.y
sub r2.x, r2.x, r2.1		; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, r1.1

	; increment sample counters of A
	add r0.xy, r0.xy, l0.xx

	add r2.x, r2.x, r2.1	; loop counter ++

   ge r2.z, r2.x, r2.y	; while(loop counter < floor(A.physWidth/2))
   break_logicalnz r2.z

	; load 4 next 4x4 blocks of B
	sample_resource(8)_sampler(8) r10, r1.xy00
	sample_resource(9)_sampler(9) r11, r1.xy00
	sample_resource(10)_sampler(10) r12, r1.xy00
	sample_resource(11)_sampler(11) r13, r1.xy00

	sample_resource(12)_sampler(12) r14, r1.xy00
	sample_resource(13)_sampler(13) r15, r1.xy00
	sample_resource(14)_sampler(14) r16, r1.xy00
	sample_resource(15)_sampler(15) r17, r1.xy00

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xz00
	sample_resource(1)_sampler(1) r27, r0.xz00
	sample_resource(2)_sampler(2) r28, r0.xz00
	sample_resource(3)_sampler(3) r29, r0.xz00
	sample_resource(4)_sampler(4) r30, r0.xz00
	sample_resource(5)_sampler(5) r31, r0.xz00
	sample_resource(6)_sampler(6) r32, r0.xz00
	sample_resource(7)_sampler(7) r33, r0.xz00

	; compute Ablk * Bblk0

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.yz00
	sample_resource(1)_sampler(1) r27, r0.yz00
	sample_resource(2)_sampler(2) r28, r0.yz00
	sample_resource(3)_sampler(3) r29, r0.yz00
	sample_resource(4)_sampler(4) r30, r0.yz00
	sample_resource(5)_sampler(5) r31, r0.yz00
	sample_resource(6)_sampler(6) r32, r0.yz00
	sample_resource(7)_sampler(7) r33, r0.yz00

	; compute Ablk * Bblk1

	; row 1
	mad r42, r26.x, r14, r34	; r42 := Ablk[0,0]*Bblk1[0,*] + Cblk[0,*]
	mad r42, r26.y, r15, r42	; r42 := Ablk[0,1]*Bblk1[1,*] + r42
	mad r42, r26.z, r16, r42	; r42 := Ablk[0,2]*Bblk1[2,*] + r42
	mad r34, r26.w, r17, r42	; Cblk[0,*] := Ablk[0,3]*Bblk1[3,*] + r42
	; row 2
	mad r42, r27.x, r14, r35
	mad r42, r27.y, r15, r42
	mad r42, r27.z, r16, r42
	mad r35, r27.w, r17, r42
	; row 3
	mad r42, r28.x, r14, r36
	mad r42, r28.y, r15, r42
	mad r42, r28.z, r16, r42
	mad r36, r28.w, r17, r42
	; row 4
	mad r42, r29.x, r14, r37
	mad r42, r29.y, r15, r42
	mad r42, r29.z, r16, r42
	mad r37, r29.w, r17, r42
	; row 5
	mad r42, r30.x, r14, r38
	mad r42, r30.y, r15, r42
	mad r42, r30.z, r16, r42
	mad r38, r30.w, r17, r42
	; row 6
	mad r42, r31.x, r14, r39
	mad r42, r31.y, r15, r42
	mad r42, r31.z, r16, r42
	mad r39, r31.w, r17, r42
	; row 7
	mad r42, r32.x, r14, r40
	mad r42, r32.y, r15, r42
	mad r42, r32.z, r16, r42
	mad r40, r32.w, r17, r42
	; row 8
	mad r42, r33.x, r14, r41
	mad r42, r33.y, r15, r42
	mad r42, r33.z, r16, r42
	mad r41, r33.w, r17, r42

endloop

mul r2.x, r2.x, l0.x	; r2.x is the loop counter, r2.y := 2*floor(A.width/2)
sub r2.x, r2.x, r2.1	; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, l0.y

	; increment sample counters of A
	add r0.x, r0.x, r0.1

	add r2.x, r2.x, r2.1	; loop counter ++

   ge r2.z, r2.x, cb0[0].x	; while(loop counter < A.width)
   break_logicalnz r2.z

	; load next 4x4 block of B

	mod r3.x, r2.x, l0.x	; r3.x := r2.x % 2

	eq r3.y, r3.x, r3.0
	if_logicalnz r3.y	; if r3.x == 0
		sample_resource(8)_sampler(8) r10, r1.xy00
		sample_resource(9)_sampler(9) r11, r1.xy00
		sample_resource(10)_sampler(10) r12, r1.xy00
		sample_resource(11)_sampler(11) r13, r1.xy00
	else
		sample_resource(12)_sampler(12) r10, r1.xy00
		sample_resource(13)_sampler(13) r11, r1.xy00
		sample_resource(14)_sampler(14) r12, r1.xy00
		sample_resource(15)_sampler(15) r13, r1.xy00
	endif

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xz00
	sample_resource(1)_sampler(1) r27, r0.xz00
	sample_resource(2)_sampler(2) r28, r0.xz00
	sample_resource(3)_sampler(3) r29, r0.xz00
	sample_resource(4)_sampler(4) r30, r0.xz00
	sample_resource(5)_sampler(5) r31, r0.xz00
	sample_resource(6)_sampler(6) r32, r0.xz00
	sample_resource(7)_sampler(7) r33, r0.xz00

	; compute Ablk * Bblk

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

endloop

; store the result
mov o0, r34
mov o1, r35
mov o2, r36
mov o3, r37
mov o4, r38
mov o5, r39
mov o6, r40
mov o7, r41
end
]]>
	</ILKernel>
	
	<ILKernel name = "MatVecMulSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Matrix vector multiplication with matrix being splitted into 8 parts: C := A*b
; 
;	inputs: 9
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0

dcl_cb cb0[1]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 0.0f, 0.5f, 0.0f, 0.0f

mov r0, r0.0000	; r0.xy is [x,y] of the first rhs element

flr r2.y, vWinCoord0.x
mul r2.y, r2.y, l0.y
flr r1.0y, r2.y			; r1.xy -> [x,y] of first element in input row
sub r2.y, r2.y, r1.y	; remainder of division by 2

sub r0.x, r0.x, r0.1		; account first increment
sub r1.x, r1.x, r1.1		; account first increment

mov r20, r20.0000
mov r21, r21.0000
mov r22, r22.0000
mov r23, r23.0000

mov r10, r10.0000			; loop counter
sub r10.x, r10.x, r10.1	; account first increment

mov r11, cb0[0]

eq r2.z, r2.y, r2.0
if_logicalnz r2.z	; if r2.y == 0

	whileloop

		; increment counters of row elements
		add r0.x, r0.x, r0.1
		add r1.x, r1.x, r1.1

		add r10.x, r10.x, r10.1	; loop counter ++
		ge r10.y, r10.x, r11.x	; while(loop counter < cb0[0].x)
		break_logicalnz r10.y

		; load next part of rhs
		sample_resource(8)_sampler(8) r5, r0.xy

		; load next parts from 4 rows
		sample_resource(0)_sampler(0) r6, r1.xy
		sample_resource(1)_sampler(1) r7, r1.xy
		sample_resource(2)_sampler(2) r8, r1.xy
		sample_resource(3)_sampler(3) r9, r1.xy

		; do elementwise multiply	
		mad r20, r5, r6, r20
		mad r21, r5, r7, r21
		mad r22, r5, r8, r22
		mad r23, r5, r9, r23
	endloop

else

	whileloop

		; increment counters of row elements
		add r0.x, r0.x, r0.1
		add r1.x, r1.x, r1.1

		add r10.x, r10.x, r10.1	; loop counter ++
		ge r10.y, r10.x, r11.x	; while(loop counter < cb0[0].x)
		break_logicalnz r10.y

		; load next part of rhs
		sample_resource(8)_sampler(8) r5, r0.xy

		; load next parts from 4 rows
		sample_resource(4)_sampler(4) r6, r1.xy
		sample_resource(5)_sampler(5) r7, r1.xy
		sample_resource(6)_sampler(6) r8, r1.xy
		sample_resource(7)_sampler(7) r9, r1.xy

		; do elementwise multiply	
		mad r20, r5, r6, r20
		mad r21, r5, r7, r21
		mad r22, r5, r8, r22
		mad r23, r5, r9, r23
	endloop

endif

; now do final horizontal add
dp4 r30.x, r20, r20.1111	; r +* ones == r.x+r.y+r.z+r.w
dp4 r30.y, r21, r21.1111
dp4 r30.z, r22, r22.1111
dp4 r30.w, r23, r23.1111

mov o0, r30

end
]]>
	</ILKernel>

	<ILKernel name = "ConvolveLines5R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 5 coefficients FIR filter: y[k] = sum_m(h[m]*x[k+m])
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x

; input position in single component elements
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r13.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r13.x, r13.x, l1.x ; x MOD 4

; load input data

ine r13.y, r13.x, r1.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	
	call 0 ; get input data in r0, r1
else
	
	sample_resource(0)_sampler(0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0 and r1 registers given r10, r11, r12 and r13.x = (x MOD 4)
func 0
	
	switch r13.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0 and r1, result is returned in r10
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10

	mul r11, r0, cb0[2]
	mad r11, r1, cb0[3], r11

	mul r12, r0, cb0[4]
	mad r12, r1, cb0[5], r12

	mul r13, r0, cb0[6]
	mad r13, r1, cb0[7], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>		
	
	<ILKernel name = "InnerProd1D_R">
<![CDATA[
il_ps_2_0
;
;	Inner product of 1D non-virtualized arrays: s := a+*b
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) [a.physWidth,...,...,...]
;
dcl_cb cb0[1]  ; [a.physWidth,...]
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

mov r4, r4.0000				; initialize accumulator

mov r0.xy, r0.00
sub r0.x, r0.x, r0.1				; account first increment

mov r2.0y00, cb0[0].x			; r2.x is the loop counter, r2.y := A.width
sub r2.x, r2.x, r2.1				; account first increment

whileloop

	add r0.x, r0.x, r0.1
	add r2.x, r2.x, r2.1			; loop counter ++

	ge r2.z, r2.x, r2.y			; while(loop counter < A.width)
	break_logicalnz r2.z

	sample_resource(0)_sampler(0) r1, r0.xy
	sample_resource(1)_sampler(1) r3, r0.xy

	mad r4, r1, r3, r4

endloop

dp4 o0.x000, r4, r4.1111

end		
]]>
	</ILKernel>	
	
</Kernels>