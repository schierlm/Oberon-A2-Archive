<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>

<Kernels>
	
	<ILKernel name = "SubCopy2DAligned_LI_R_LR">		
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when arrays are non virtualized and copy regions are aligned to
;	nComponents (srcOrigin[1] MOD nComponents = 0) & (dstOrigin[1] MOD nComponents = 0) & (size[1] MOD nComponents) = 0)
;	for both input and output
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: any
;	constants: 1 (REAL) : [(srcOrigin[1]-dstOrigin[1]) DIV nComponents,srcOrigin[0]-dstOrigin[0],...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

add r0.xy, vWinCoord0.xy, cb0[0].xy	; compute position in the input
sample_resource(0)_sampler(0) r1, r0
mov o0, r1
end
]]>
	</ILKernel>
	
	<ILKernel name = "SubCopy2DUnaligned_LI_R_4">
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when arrays are non virtualized and copy regions are not aligned to
;	nComponents (srcOrigin[1] MOD nComponents # 0) OR (dstOrigin[1] MOD nComponents # 0) OR (subSize[1] MOD nComponents) # 0)
; 
;	inputs: 2 (src,dst)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 (same for input and output)
;	constants: 1,  2 x 4 (LONGINT) : [srcOrigin[1],srcOrigin[0],dstOrigin[1],dstOrigin[0]];  [subSize[1],subSize[0],dstOrigin[1] DIV 4,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[2]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, -1, -1, 0

ftoi r0.xy, vWinCoord0.xy ; convert output position in multi-component elements  to integers
mov r0.z, r0.x ; r0.z := Int(vWinCoord0.x)

; output position in single-component elements
umul r0.x, r0.x, l0.x ; x*4

; account unaligned dstOrigin[1]
ieq r4.x, r0.z, cb0[1].z ; Int(vWinCoord0.x) = dstOrigin[1] DIV 4
if_logicalnz r4.x
	umod r4.x, cb0[0].z, l0.x ; dstOrigin[1] MOD 4
	iadd r0.x, r0.x, r4.x
endif

; input position in single-component elements
umad r1.xy, cb0[0].zw, l0.yz, cb0[0].xy ; [srcOrigin[1],srcOrigin[0]] - [dstOrigin[1],dstOrigin[0]]
iadd r1.xy, r0.xy, r1.xy

umod r4.x, r1.x, l0.x ; input.x MOD 4
udiv r1.x, r1.x, l0.x ; input position in multi-component elements
itof r1.xy, r1.xy

switch r4.x
	
	case 0
		sample_resource(0)_sampler(0) r3.xyzw, r1.xy
	break
		
	case 1		
		sample_resource(0)_sampler(0) r3._yzw, r1.xy		
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.x___, r1.xy
		mov r3.xyzw, r3.yzwx
	break
	
	case 2
		sample_resource(0)_sampler(0) r3.__zw, r1.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.xy__, r1.xy		
		mov r3.xyzw, r3.zwxy
	break
	
	case 3
		sample_resource(0)_sampler(0) r3.___w, r1.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.xyz_, r1.xy
		mov r3.xyzw, r3.wxyz
	break
endswitch

; write to the output

iadd r4.x, cb0[0].z, cb0[1].x ; dstOrigin[1] + subSize[1]	
iadd r4.x, r4.x, l0.y ; dstOrigin[1] + subSize[1] - 1 ; right dst bound in single-component elements	
udiv r4.y, r4.x, l0.x ; (dstOrigin[1] + subSize[1] - 1) DIV 4 ; right dst bound in multi-component elements

ine r4.z, r0.z, cb0[1].z ; output.x # (dstOrigin[1] DIV 4) -> not the left dst bound
if_logicalnz r4.z		
	
	ine r4.z, r0.z, r4.y ; Int(vWinCoord0.x) # (dstOrigin[1] + subSize[1] - 1) DIV 4 -> not the right dst bound
	if_logicalnz r4.z
		mov o0.xyzw, r3.xyzw
	else
		
		umod r4.z, r4.x, l0.x ; (dstOrigin[1] + subSize[1] - 1) MOD 4
		
		switch r4.z
			
			case 0
				sample_resource(1)_sampler(1) r3._yzw, vWinCoord0.xy
				mov o0, r3
			break
			
			case 1
				sample_resource(1)_sampler(1) r3.__zw, vWinCoord0.xy
				mov o0, r3
			break
			
			case 2
				sample_resource(1)_sampler(1) r3.___w, vWinCoord0.xy
				mov o0, r3
			break
			
			case 3
				mov o0, r3
			break
		endswitch
		
	endif	
	
else ; the left dst bound

	ine r4.z, r0.z, r4.y ; Int(vWinCoord0.x) # (dstOrigin[1] + subSize[1] - 1) DIV 4 -> not the right dst bound
	if_logicalnz r4.z
			
		umod r4.z, cb0[0].z, l0.x ; dstOrigin[1] MOD 4
		
		switch r4.z						
		
			case 0
				mov o0, r3
			break
			
			case 1
				mov r3.0yzw, r3.0xyz
				sample_resource(1)_sampler(1) r3.x___, vWinCoord0.xy
				mov o0, r3
			break
			
			case 2
				mov r3.00zw, r3.00xy
				sample_resource(1)_sampler(1) r3.xy__, vWinCoord0.xy
				mov o0, r3
			break
			
			case 3
				mov r3.000w, r3.000x
				sample_resource(1)_sampler(1) r3.xyz_, vWinCoord0.xy
				mov o0, r3
			break
									
		endswitch				
			
	else ; very specific case when subSize[1] <= nComponents			
	
		umod r4.x, cb0[0].z, l0.x; dstOrigin[1] MOD 4		
		
		switch r4.x
			
			case 0				
				switch cb0[1].x ; subSize[1]
				
					case 1
						sample_resource(1)_sampler(1) r3._yzw, vWinCoord0.xy
						mov o0, r3
					break
					
					case 2
						sample_resource(1)_sampler(1) r3.__zw, vWinCoord0.xy
					mov o0, r3
					break
					
					case 3
						sample_resource(1)_sampler(1) r3.___w, vWinCoord0.xy
						mov o0, r3
					break
					
					case 4
						mov o0, r3
					break
										
				endswitch;
			break
			
			case 1
				switch cb0[1].x ; subSize[1]
					case 1
						mov r3.y, r3.x
						sample_resource(1)_sampler(1) r3.x_zw, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 2
						mov r3.0yz0, r3.0xy0
						sample_resource(1)_sampler(1) r3.x__w, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 3
						mov r3.0yzw, r3.0xyz
						sample_resource(1)_sampler(1) r3.x___, vWinCoord0.xy	
						mov o0, r3
					break										
				endswitch;
			break
			
			case 2
				switch cb0[1].x ; subSize[1]
					case 1
						mov r3.z, r3.x
						sample_resource(1)_sampler(1) r3.xy_w, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 2
						mov r3.00zw, r3.00xy
						sample_resource(1)_sampler(1) r3.xy__, vWinCoord0.xy
						mov o0, r3
					break										
				endswitch;
			break
			
			case 3				
				mov r3.w, r3.x
				sample_resource(1)_sampler(1) r3.xyz_, vWinCoord0.xy
				mov o0, r3
			break
		endswitch				
		
	endif

endif								

end				
]]>	
	</ILKernel>
	
	<ILKernel name = "SubCopy2DNonVirtToVirt_LI_R_4">					
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when source array is not virtualized and destination is virtualized
; 
;	inputs: 1 (src)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 - for the input, 1 - for the output (virtualized)
;	constants: 1, 2x4 (LONGINT) : [srcOrigin[1]-dstOrigin[1],srcOrigin[0]-dstOrigin[0],dst.Width,dst.physWidth]; [dstOrigin[1],dstOrigin[0],dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[2]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, 0, 0, 0

; compute linear index in the output
ftoi r0.xy, vWinCoord0.xy
umad r0.x, r0.y, cb0[0].w, r0.x ; ind := y*dst.physWidth + x

; compute non-virtual position in the output
udiv r0.y, r0.x, cb0[0].z ; y := ind DIV dst.Width
umod r0.x, r0.x, cb0[0].z

ilt r1.xy, r0.xy, cb0[1].xy ; [x,y] < [dstOrigin[1],dstOrigin[0]]
inot r1.xy, r1.xy ;  ~([x,y] < [dstOrigin[1],dstOrigin[0]]) -> [x,y] >= [dstOrigin[1],dstOrigin[0]]
ilt r2.xy, r0.xy, cb0[1].zw ; [x,y] < [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
and r1.xy, r1.xy, r2.xy
ieq r2.xy, r0.xy, cb0[1].zw ; [x,y] = [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
ior r1.xy, r1.xy, r2.xy ; ([x,y] >= [dstOrigin[1],dstOrigin[0]]) & ([x,y] <= [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1])

and r1.x, r1.x, r1.y
if_logicalnz r1.x

	; compute 2D position in the input, in single-component elements
	iadd r0.xy, r0.xy, cb0[0].xy

	umod r0.z, r0.x, l0.x ; x MOD 4

	udiv r0.x, r0.x, l0.x ; input position in multi-component elements
	itof r0.xy, r0.xy ; convert [x,y] to floats

	switch r0.z
		
		case 0
			sample_resource(0)_sampler(0) o0.x, r0.xy
		break
		
		case 1
			sample_resource(0)_sampler(0) r1._y__, r0.xy
			mov o0.x, r1.y
		break
		
		case 2
			sample_resource(0)_sampler(0) r1.__z_, r0.xy
			mov o0.x, r1.z
		break
	
		case 3
			sample_resource(0)_sampler(0) r1.___w, r0.xy
			mov o0.x, r1.w
		break
	endswitch	

else
	sample_resource(1)_sampler(1) o0.x, vWinCoord0.xy	
endif

end				
]]>	
	</ILKernel>
	
	<ILKernel name = "SubCopy2DVirtToNonVirtAligned_LI_R_4">	
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when source array is virtualized, destination is not virtualized, and copy regions are aligned to
;	nComponents (dstOrigin[1] MOD nComponents = 0) & (subSize[1] MOD nComponents) = 0)
; 
;	inputs: 1 (src)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 - for the output, 1 - for the input (virtualized)
;	constants: 1 (LONGINT) : [srcOrigin[1]-dstOrigin[1],srcOrigin[0]-dstOrigin[0],src.Width,src.physWidth]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, -1, 0, 0

; compute non-virtual position in the input
ftoi r0.xy, vWinCoord0.xy
umul r0.x, r0.x, l0.x ; output position in single-component elements
iadd r0.xy, r0.xy, cb0[0].xy ; input position in single-component elements

; compute linear index in the input
umad r1.x, r0.y, cb0[0].z, r0.x ; ind := y*src.Width + x

; compute 2D virtual position in the input
udiv r1.y, r1.x, cb0[0].w ; y := ind DIV src.physWidth
umod r1.x, r1.x, cb0[0].w ; x := ind MOD src.physWidth

umad r4.x, r1.x, l0.y, cb0[0].w ; r4.x := src.physWidth - x

itof r1.xy, r1.xy

ige r4.z, r4.x, l0.x ; src.physWidth - x >= 4
if_logicalnz r4.z		
	
	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) o0.x, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) o0.y, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) o0.z, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) o0.w, r1.xy
		
else
	
	itof r5.x, cb0[0].w
	
	add r2.xy, r1.xy, r1.10
	ge r5.z, r2.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r2.0y, r2.y, r2.1 ; INC(y)
	endif
	
	add r3.xy, r2.xy, r2.10
	ge r5.z, r3.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r3.0y, r3.y, r3.1 ; INC(y)
	endif
	
	add r4.xy, r3.xy, r3.10
	ge r5.z, r4.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r4.0y, r4.y, r4.1 ; INC(y)
	endif
	
	sample_resource(0)_sampler(0) o0.x, r1.xy
	sample_resource(0)_sampler(0) o0.y, r2.xy
	sample_resource(0)_sampler(0) o0.z, r3.xy
	sample_resource(0)_sampler(0) o0.w, r4.xy
		
endif

end
]]>	
	</ILKernel>
	
	<ILKernel name = "ClearMemory">
<![CDATA[
il_ps_2_0
;
;	Clear GPU memory resource
; 
;	inputs: 0
;	outputs: 1
;	data type: any
;	nComponents: any
;	constants: 0
;
dcl_output_generic o0
mov r0, r0.0000
mov o0, r0
end
]]>						
	</ILKernel>
	
	<ILKernel name = "Add_R">
<![CDATA[
il_ps_2_0
;
;	Array addition
; 
;	inputs: 2
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
add o0, r0, r1
end		
]]>
	</ILKernel>
	
	<ILKernel name = "AddScalar_R">
<![CDATA[
il_ps_2_0
;
;	Array + Scalar
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
add o0, r0, cb0[0]
end		
]]>
	</ILKernel>
	
	<ILKernel name = "Sub_R">
<![CDATA[
il_ps_2_0
;
;	Array subtraction
; 
;	inputs: 2
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sub o0, r0, r1
end		
]]>
	</ILKernel>
		
	<ILKernel name = "ScalarSub_R">
<![CDATA[
il_ps_2_0
;
;	Scalar - Array
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sub o0, cb0[0], r0
end		
]]>
	</ILKernel>
	
	<ILKernel name = "EwMul_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
mul o0, r0, r1
end
]]>
	</ILKernel>
	
	<ILKernel name = "MulByScalar_R">
<![CDATA[
il_ps_2_0
;
;	Array * Scalar
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
mul o0, r0, cb0[0]
end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwDiv_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication
; 
;	inputs: 2
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
div_zeroop(inf_else_max) o0, r0, r1
end
]]>
	</ILKernel>
	
	<ILKernel name = "DivByScalar_R">
<![CDATA[
il_ps_2_0
;
;	Array / Scalar
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
div_zeroop(inf_else_max) o0, r0, cb0[0]
end		
]]>
	</ILKernel>	
	
	<ILKernel name = "ScalarEwDiv_R">
<![CDATA[
il_ps_2_0
;
;	Scalar ./ Array
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_cb cb0[1] ; [scalar,scalar,scalar,scalar]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
sample_resource(0)_sampler(0) r0, vWinCoord0
div_zeroop(inf_else_max) o0, cb0[0], r0
end		
]]>
	</ILKernel>
	
	<ILKernel name = "AddSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Addition of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

add o0, r0, r8
add o1, r1, r9
add o2, r2, r10
add o3, r3, r11
add o4, r4, r12
add o5, r5, r13
add o6, r6, r14
add o7, r7, r15

end		
]]>
	</ILKernel>		
	
	<ILKernel name = "SubSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Subtraction of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

sub o0, r0, r8
sub o1, r1, r9
sub o2, r2, r10
sub o3, r3, r11
sub o4, r4, r12
sub o5, r5, r13
sub o6, r6, r14
sub o7, r7, r15

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwMulSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

mul o0, r0, r8
mul o1, r1, r9
mul o2, r2, r10
mul o3, r3, r11
mul o4, r4, r12
mul o5, r5, r13
mul o6, r6, r14
mul o7, r7, r15

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwDivSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise division of splitted matrices with 8 parts
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0
sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sample_resource(8)_sampler(8) r8, vWinCoord0
sample_resource(9)_sampler(9) r9, vWinCoord0
sample_resource(10)_sampler(10) r10, vWinCoord0
sample_resource(11)_sampler(11) r11, vWinCoord0
sample_resource(12)_sampler(12) r12, vWinCoord0
sample_resource(13)_sampler(13) r13, vWinCoord0
sample_resource(14)_sampler(14) r14, vWinCoord0
sample_resource(15)_sampler(15) r15, vWinCoord0

div_zeroop(inf_else_max) o0, r0, r8
div_zeroop(inf_else_max) o1, r1, r9
div_zeroop(inf_else_max) o2, r2, r10
div_zeroop(inf_else_max) o3, r3, r11
div_zeroop(inf_else_max) o4, r4, r12
div_zeroop(inf_else_max) o5, r5, r13
div_zeroop(inf_else_max) o6, r6, r14
div_zeroop(inf_else_max) o7, r7, r15

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "AddSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Addition of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

add o0, r0, r4
add o1, r1, r5
add o2, r2, r6
add o3, r3, r7

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "SubSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Subtraction of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)


sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

sub o0, r0, r4
sub o1, r1, r5
sub o2, r2, r6
sub o3, r3, r7

end		
]]>
	</ILKernel>		
	
	<ILKernel name = "EwMulSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise multiplication of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

mul o0, r0, r4
mul o1, r1, r5
mul o2, r2, r6
mul o3, r3, r7

end		
]]>
	</ILKernel>	
	
	<ILKernel name = "EwDivSplitted4_R">
<![CDATA[
il_ps_2_0
;
;	Elementwise division of splitted matrices with 4 parts
; 
;	inputs: 8
;	outputs: 4
;	data type: REAL
;	nComponents: any
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

sample_resource(0)_sampler(0) r0, vWinCoord0
sample_resource(1)_sampler(1) r1, vWinCoord0
sample_resource(2)_sampler(2) r2, vWinCoord0
sample_resource(3)_sampler(3) r3, vWinCoord0

sample_resource(4)_sampler(4) r4, vWinCoord0
sample_resource(5)_sampler(5) r5, vWinCoord0
sample_resource(6)_sampler(6) r6, vWinCoord0
sample_resource(7)_sampler(7) r7, vWinCoord0

div_zeroop(inf_else_max) o0, r0, r4
div_zeroop(inf_else_max) o1, r1, r5
div_zeroop(inf_else_max) o2, r2, r6
div_zeroop(inf_else_max) o3, r3, r7

end		
]]>
	</ILKernel>
	
	<ILKernel name = "MatMulSplitted8_R">		
<![CDATA[
il_ps_2_0
;
;	Multiplication of matrices splitted into 8 parts: C := A*B
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_cb cb0[1]	; [A.physWidth,...]

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

; parts of A
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

; parts of B
dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; initialize sample counters of A
mov r0.0y, vWinCoord0.y		; r0 := [0,y]
sub r0.x, r0.x, r0.1				; account first increment

; initialize sample counter of B
mov r1.x0, vWinCoord0.x		; [x,0]
sub r1.y, r1.y, l0.y				; account first increment

; clear float4 accumulators for 8x4 * 4x4 matrix multiply result
mov r34, r34.0000	
mov r35, r35.0000
mov r36, r36.0000
mov r37, r37.0000
mov r38, r38.0000	
mov r39, r39.0000
mov r40, r40.0000
mov r41, r41.0000

mov r2.0y00, cb0[0].x			; r2.x is the loop counter, r2.y := A.width
sub r2.x, r2.x, r2.1				; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, l0.y

	; increment sample counter of A
	add r0.x, r0.x, r0.1

	add r2.x, r2.x, r2.1	; loop counter ++

   	ge r2.z, r2.x, r2.y	; while(loop counter < A.physWidth)
   	break_logicalnz r2.z

	; load next 4x4 block of B

	mod r3.x, r2.x, l0.x	; r3.x := r2.x % 2

	eq r3.y, r3.x, r3.0
	if_logicalnz r3.y	; if r3.x == 0
		sample_resource(8)_sampler(8) r10, r1.xy00
		sample_resource(9)_sampler(9) r11, r1.xy00
		sample_resource(10)_sampler(10) r12, r1.xy00
		sample_resource(11)_sampler(11) r13, r1.xy00
	else
		sample_resource(12)_sampler(12) r10, r1.xy00
		sample_resource(13)_sampler(13) r11, r1.xy00
		sample_resource(14)_sampler(14) r12, r1.xy00
		sample_resource(15)_sampler(15) r13, r1.xy00
	endif

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xy00
	sample_resource(1)_sampler(1) r27, r0.xy00
	sample_resource(2)_sampler(2) r28, r0.xy00
	sample_resource(3)_sampler(3) r29, r0.xy00
	sample_resource(4)_sampler(4) r30, r0.xy00
	sample_resource(5)_sampler(5) r31, r0.xy00
	sample_resource(6)_sampler(6) r32, r0.xy00
	sample_resource(7)_sampler(7) r33, r0.xy00

	; compute Ablk * Bblk

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

endloop

; store the result
mov o0, r34
mov o1, r35
mov o2, r36
mov o3, r37
mov o4, r38
mov o5, r39
mov o6, r40
mov o7, r41

end
]]>
	</ILKernel>
	
	<ILKernel name = "MatMulSplitted8Unroll2_R">		
<![CDATA[
il_ps_2_0
;
;	Multiplication of matrices splitted into 8 parts: C := A*B
; 	use loop unrolling by 2
;
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_cb cb0[1]	; [A.physWidth,...]

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; initialize sample counters of A
mov r0.01z0, vWinCoord0.00y0		; r0 := [0,1,y,0]
sub r0.xy, r0.xy, l0.xx					; account first increment

; initialize sample counter of B
mov r1.x0, vWinCoord0.x			; [x,0,1,...]
sub r1.y, r1.y, r1.1					; account first increment

; clear float4 accumulators for 8x4 * 4x4 matrix multiply result
mov r34, r34.0000	
mov r35, r35.0000
mov r36, r36.0000
mov r37, r37.0000
mov r38, r38.0000	
mov r39, r39.0000
mov r40, r40.0000
mov r41, r41.0000

mul r2.0y, l0.y, cb0[0].x	; r2.x is the loop counter, r2.y := floor(A.physWidth/2)
flr r2.y, r2.y
sub r2.x, r2.x, r2.1		; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, r1.1

	; increment sample counters of A
	add r0.xy, r0.xy, l0.xx

	add r2.x, r2.x, r2.1	; loop counter ++

   ge r2.z, r2.x, r2.y	; while(loop counter < floor(A.physWidth/2))
   break_logicalnz r2.z

	; load 4 next 4x4 blocks of B
	sample_resource(8)_sampler(8) r10, r1.xy00
	sample_resource(9)_sampler(9) r11, r1.xy00
	sample_resource(10)_sampler(10) r12, r1.xy00
	sample_resource(11)_sampler(11) r13, r1.xy00

	sample_resource(12)_sampler(12) r14, r1.xy00
	sample_resource(13)_sampler(13) r15, r1.xy00
	sample_resource(14)_sampler(14) r16, r1.xy00
	sample_resource(15)_sampler(15) r17, r1.xy00

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xz00
	sample_resource(1)_sampler(1) r27, r0.xz00
	sample_resource(2)_sampler(2) r28, r0.xz00
	sample_resource(3)_sampler(3) r29, r0.xz00
	sample_resource(4)_sampler(4) r30, r0.xz00
	sample_resource(5)_sampler(5) r31, r0.xz00
	sample_resource(6)_sampler(6) r32, r0.xz00
	sample_resource(7)_sampler(7) r33, r0.xz00

	; compute Ablk * Bblk0

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.yz00
	sample_resource(1)_sampler(1) r27, r0.yz00
	sample_resource(2)_sampler(2) r28, r0.yz00
	sample_resource(3)_sampler(3) r29, r0.yz00
	sample_resource(4)_sampler(4) r30, r0.yz00
	sample_resource(5)_sampler(5) r31, r0.yz00
	sample_resource(6)_sampler(6) r32, r0.yz00
	sample_resource(7)_sampler(7) r33, r0.yz00

	; compute Ablk * Bblk1

	; row 1
	mad r42, r26.x, r14, r34	; r42 := Ablk[0,0]*Bblk1[0,*] + Cblk[0,*]
	mad r42, r26.y, r15, r42	; r42 := Ablk[0,1]*Bblk1[1,*] + r42
	mad r42, r26.z, r16, r42	; r42 := Ablk[0,2]*Bblk1[2,*] + r42
	mad r34, r26.w, r17, r42	; Cblk[0,*] := Ablk[0,3]*Bblk1[3,*] + r42
	; row 2
	mad r42, r27.x, r14, r35
	mad r42, r27.y, r15, r42
	mad r42, r27.z, r16, r42
	mad r35, r27.w, r17, r42
	; row 3
	mad r42, r28.x, r14, r36
	mad r42, r28.y, r15, r42
	mad r42, r28.z, r16, r42
	mad r36, r28.w, r17, r42
	; row 4
	mad r42, r29.x, r14, r37
	mad r42, r29.y, r15, r42
	mad r42, r29.z, r16, r42
	mad r37, r29.w, r17, r42
	; row 5
	mad r42, r30.x, r14, r38
	mad r42, r30.y, r15, r42
	mad r42, r30.z, r16, r42
	mad r38, r30.w, r17, r42
	; row 6
	mad r42, r31.x, r14, r39
	mad r42, r31.y, r15, r42
	mad r42, r31.z, r16, r42
	mad r39, r31.w, r17, r42
	; row 7
	mad r42, r32.x, r14, r40
	mad r42, r32.y, r15, r42
	mad r42, r32.z, r16, r42
	mad r40, r32.w, r17, r42
	; row 8
	mad r42, r33.x, r14, r41
	mad r42, r33.y, r15, r42
	mad r42, r33.z, r16, r42
	mad r41, r33.w, r17, r42

endloop

mul r2.x, r2.x, l0.x	; r2.x is the loop counter, r2.y := 2*floor(A.width/2)
sub r2.x, r2.x, r2.1	; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, l0.y

	; increment sample counters of A
	add r0.x, r0.x, r0.1

	add r2.x, r2.x, r2.1	; loop counter ++

   ge r2.z, r2.x, cb0[0].x	; while(loop counter < A.width)
   break_logicalnz r2.z

	; load next 4x4 block of B

	mod r3.x, r2.x, l0.x	; r3.x := r2.x % 2

	eq r3.y, r3.x, r3.0
	if_logicalnz r3.y	; if r3.x == 0
		sample_resource(8)_sampler(8) r10, r1.xy00
		sample_resource(9)_sampler(9) r11, r1.xy00
		sample_resource(10)_sampler(10) r12, r1.xy00
		sample_resource(11)_sampler(11) r13, r1.xy00
	else
		sample_resource(12)_sampler(12) r10, r1.xy00
		sample_resource(13)_sampler(13) r11, r1.xy00
		sample_resource(14)_sampler(14) r12, r1.xy00
		sample_resource(15)_sampler(15) r13, r1.xy00
	endif

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xz00
	sample_resource(1)_sampler(1) r27, r0.xz00
	sample_resource(2)_sampler(2) r28, r0.xz00
	sample_resource(3)_sampler(3) r29, r0.xz00
	sample_resource(4)_sampler(4) r30, r0.xz00
	sample_resource(5)_sampler(5) r31, r0.xz00
	sample_resource(6)_sampler(6) r32, r0.xz00
	sample_resource(7)_sampler(7) r33, r0.xz00

	; compute Ablk * Bblk

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

endloop

; store the result
mov o0, r34
mov o1, r35
mov o2, r36
mov o3, r37
mov o4, r38
mov o5, r39
mov o6, r40
mov o7, r41
end
]]>
	</ILKernel>
	
	<ILKernel name = "MatVecMulSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Matrix vector multiplication with matrix being splitted into 8 parts: C := A*b
; 
;	inputs: 9
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0

dcl_cb cb0[1]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 0.0f, 0.5f, 0.0f, 0.0f

mov r0, r0.0000	; r0.xy is [x,y] of the first rhs element

flr r2.y, vWinCoord0.x
mul r2.y, r2.y, l0.y
flr r1.0y, r2.y		; r1.xy -> [x,y] of first element in input row
sub r2.y, r2.y, r1.y	; remainder of division by 2

sub r0.x, r0.x, r0.1		; account first increment
sub r1.x, r1.x, r1.1		; account first increment

mov r20, r20.0000
mov r21, r21.0000
mov r22, r22.0000
mov r23, r23.0000

mov r10, r10.0000			; loop counter
sub r10.x, r10.x, r10.1	; account first increment

mov r11, cb0[0]

eq r2.z, r2.y, r2.0
if_logicalnz r2.z	; if frac(y/2) == 0

	whileloop

		; increment counters of row elements
		add r0.x, r0.x, r0.1
		add r1.x, r1.x, r1.1

		add r10.x, r10.x, r10.1	; loop counter ++
		ge r10.y, r10.x, r11.x	; while(loop counter < cb0[0].x)
		break_logicalnz r10.y

		; load next part of rhs
		sample_resource(8)_sampler(8) r5, r0.xy

		; load next parts from 4 rows
		sample_resource(0)_sampler(0) r6, r1.xy
		sample_resource(1)_sampler(1) r7, r1.xy
		sample_resource(2)_sampler(2) r8, r1.xy
		sample_resource(3)_sampler(3) r9, r1.xy

		; do elementwise multiply	
		mad r20, r5, r6, r20
		mad r21, r5, r7, r21
		mad r22, r5, r8, r22
		mad r23, r5, r9, r23
	endloop

else

	whileloop

		; increment counters of row elements
		add r0.x, r0.x, r0.1
		add r1.x, r1.x, r1.1

		add r10.x, r10.x, r10.1	; loop counter ++
		ge r10.y, r10.x, r11.x	; while(loop counter < cb0[0].x)
		break_logicalnz r10.y

		; load next part of rhs
		sample_resource(8)_sampler(8) r5, r0.xy

		; load next parts from 4 rows
		sample_resource(4)_sampler(4) r6, r1.xy
		sample_resource(5)_sampler(5) r7, r1.xy
		sample_resource(6)_sampler(6) r8, r1.xy
		sample_resource(7)_sampler(7) r9, r1.xy

		; do elementwise multiply	
		mad r20, r5, r6, r20
		mad r21, r5, r7, r21
		mad r22, r5, r8, r22
		mad r23, r5, r9, r23
	endloop

endif

; now do final horizontal add
dp4 r30.x, r20, r20.1111	; r +* ones == r.x+r.y+r.z+r.w
dp4 r30.y, r21, r21.1111
dp4 r30.z, r22, r22.1111
dp4 r30.w, r23, r23.1111

mov o0, r30

end
]]>
	</ILKernel>

	<ILKernel name = "ConvolveLines5_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 5 coefficients FIR filter: y[k] = sum_m(h[m]*x[k+m])
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x ; x := x*4

; input position in single component elements
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r13.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r13.x, r13.x, l1.x ; x MOD 4

; load input data

ine r13.y, r13.x, r13.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	
	call 0 ; get input data in r0, r1
else
	
	sample_resource(0)_sampler(0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0 and r1 registers given r10, r11, r12 and r13.x = (x MOD 4)
func 0
	
	switch r13.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0 and r1, result is returned in r10
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10

	mul r11, r0, cb0[2]
	mad r11, r1, cb0[3], r11

	mul r12, r0, cb0[4]
	mad r12, r1, cb0[5], r12

	mul r13, r0, cb0[6]
	mad r13, r1, cb0[7], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>		
	
	<ILKernel name = "TransposeSplitted8_R">
<![CDATA[
il_ps_2_0
;
;	Transposition of matrices splitted into 8 parts
; 
;	inputs: 8
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; compute position in the input
flr r0.xy, vWinCoord0.yx
mul r0.xy, r0.xy, l0.xy ; [x*2, y/ 2]
frc r1.y, r0.y ; r1.y := frac(y/2)
flr r0.y, r0.y

eq r1.z, r1.y, r1.0
if_logicalnz r1.z	; if frac(y/2) == 0

	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r1, r0.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r2, r0.xy
	
	sample_resource(1)_sampler(1)_aoffimmi(0,0,0) r3, r0.xy
	sample_resource(1)_sampler(1)_aoffimmi(1,0,0) r4, r0.xy
	
	sample_resource(2)_sampler(2)_aoffimmi(0,0,0) r5, r0.xy
	sample_resource(2)_sampler(2)_aoffimmi(1,0,0) r6, r0.xy
	
	sample_resource(3)_sampler(3)_aoffimmi(0,0,0) r7, r0.xy
	sample_resource(3)_sampler(3)_aoffimmi(1,0,0) r8, r0.xy
else			
		
	sample_resource(4)_sampler(4)_aoffimmi(0,0,0) r1, r0.xy
	sample_resource(4)_sampler(4)_aoffimmi(1,0,0) r2, r0.xy
	
	sample_resource(5)_sampler(5)_aoffimmi(0,0,0) r3, r0.xy
	sample_resource(5)_sampler(5)_aoffimmi(1,0,0) r4, r0.xy
	
	sample_resource(6)_sampler(6)_aoffimmi(0,0,0) r5, r0.xy
	sample_resource(6)_sampler(6)_aoffimmi(1,0,0) r6, r0.xy
	
	sample_resource(7)_sampler(7)_aoffimmi(0,0,0) r7, r0.xy
	sample_resource(7)_sampler(7)_aoffimmi(1,0,0) r8, r0.xy
endif

	mov r10.x, r1.x
	mov r10.y, r3.x
	mov r10.z, r5.x
	mov r10.w, r7.x	
	
	mov r11.x, r1.y
	mov r11.y, r3.y
	mov r11.z, r5.y
	mov r11.w, r7.y
	
	mov r12.x, r1.z
	mov r12.y, r3.z
	mov r12.z, r5.z
	mov r12.w, r7.z
	
	mov r13.x, r1.w
	mov r13.y, r3.w
	mov r13.z, r5.w
	mov r13.w, r7.w
	
	;
	
	mov r14.x, r2.x
	mov r14.y, r4.x
	mov r14.z, r6.x
	mov r14.w, r8.x 
	
	mov r15.x, r2.y
	mov r15.y, r4.y
	mov r15.z, r6.y
	mov r15.w, r8.y
	
	mov r16.x, r2.z
	mov r16.y, r4.z
	mov r16.z, r6.z
	mov r16.w, r8.z
	
	mov r17.x, r2.w
	mov r17.y, r4.w
	mov r17.z, r6.w
	mov r17.w, r8.w
	
	mov o0, r10
	mov o1, r11
	mov o2, r12
	mov o3, r13
	mov o4, r14
	mov o5, r15
	mov o6, r16
	mov o7, r17		
	
end		
]]>
	</ILKernel>	
	
	<ILKernel name = "ConvolveLines5Down2_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 5 coefficients FIR filter combined with downsampling by 2
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 8.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in multi component elements
flr r0.xy, vWinCoord0.xy

; input position in single component elements
mul r0.x, r0.x, l0.x
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r13.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r14.x, r13.x, l1.x ; x MOD 4

; load input data

ine r13.y, r14.x, r14.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r13, r20.xy
	
	call 0 ; get input data in r0, r1, r2
else
	
	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r2, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0, r1, r2 registers given r10, r11, r12, r13 and r14.x = (x MOD 4)
func 0
	
	switch r14.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
			
			mov r2.xyz_, r12.yzw0
			mov r2.w, r13.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
			
			mov r2.xy__, r12.zw00
			mov r2.__zw, r13.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
			
			mov r2.x___, r12.w000
			mov r2._yzw, r13.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0, r1, r2 result is returned in r10
func 1
	
	; #TODO:  optimize
	
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10

	mul r11, r0, cb0[2]
	mad r11, r1, cb0[3], r11

	mul r12, r0, cb0[4]
	mad r12, r1, cb0[5], r12

	mul r13, r0, cb0[6]
	mad r13, r1, cb0[7], r13
	
	dp4 r14.x, r10, r10.1111
	dp4 r14.y, r11, r11.1111
	dp4 r14.z, r12, r12.1111
	dp4 r14.w, r13, r13.1111
	
	mul r10, r1, cb0[0]
	mad r10, r2, cb0[1], r10

	mul r11, r1, cb0[2]
	mad r11, r2, cb0[3], r11

	mul r12, r1, cb0[4]
	mad r12, r2, cb0[5], r12

	mul r13, r1, cb0[6]
	mad r13, r2, cb0[7], r13
	
	dp4 r15.x, r10, r10.1111
	dp4 r15.y, r11, r11.1111
	dp4 r15.z, r12, r12.1111
	dp4 r15.w, r13, r13.1111
	
	mov r10.xy__, r14.xz00
	mov r10.__zw, r15.00xz
ret
endfunc

end
]]>
	</ILKernel>
	
	<ILKernel name = "ConvolveLines5Up2_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 5 coefficients FIR filter combined with upsampling by 2
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.5f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x ; x := x*4
sub r0.x, r0.x, cb1[0].x ; x - hotSpot

; input position in single component elements
add r0.x, r0.x, r0.1 ; x := x + 1
mul r0.x, r0.x, l0.z ; x := x / 2
frc r14.x, r0.x ; fraction(x/2)
ftoi r13.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r13.x, r13.x, l1.x ; x MOD 4

; load input data

ine r13.y, r13.x, r13.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy		
	
	call 0 ; get input data in r0		
else
	
	sample_resource(0)_sampler(0) r0, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0 register given r10, r11 and r13.x = (x MOD 4)
func 0
	
	switch r13.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x						
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy						
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0 and r14.x = fraction(x/2), result is returned in r10
func 1
	
	; account upsampling by 2
	ne r14.x, r14.x, r14.0 ; fraction(x/2) # 0
	if_logicalnz r14.x
		
		mov r1.x0z0, r0.x0y0
		mov r2.x0z0, r0.z0w0
	else
		
		mov r1.0y0w, r0.0x0y
		mov r2.0y0w, r0.0z0w
	endif
	
	mul r10, r1, cb0[0]
	mad r10, r2, cb0[1], r10

	mul r11, r1, cb0[2]
	mad r11, r2, cb0[3], r11

	mul r12, r1, cb0[4]
	mad r12, r2, cb0[5], r12

	mul r13, r1, cb0[6]
	mad r13, r2, cb0[7], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>		
	
	
	<ILKernel name = "Inv8x8_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Inversion of a matrix 8x8
; 
;	inputs: 0
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 0
;

mov r0, g[0]
mov r1, g[1]
mov r2, g[2]
mov r3, g[3]

call 3

fence_memory

mov g[0], r0
mov g[1], r1
mov g[2], r2
mov g[3], r3

endmain

; 2x2 matrix multiplication
;	r0: [x, y; z,w] - lhs, r1: [x, y; z,w] - rhs
;	result is in r0, uses r>100 as stack
func 0
	; push to the stack
	mov r100, r2
	
	; first row of the result
	mul r2.xy, r0.xx, r1.xy
	mad r0.xy, r0.yy, r1.zw, r2.xy
	
	; second row of the result
	mul r2.xy, r0.zz, r1.xy
	mad r0.__zw, r0.00ww, r1.00zw, r2.00xy
	
	; pop from the stack
	mov r2, r100
ret
endfunc

; 4x4 matrix multiplication
;	r0, r1, r2, r3 - lhs, r4, r5, r6, r7 - rhs
;	result is in r0, r1, r2, r3, uses r>100 as stack
func 1
	; push to the stack
	mov r100, r8
	
	; row 1
	mul r8, r0.xxxx, r4
	mad r8, r0.yyyy, r5, r8
	mad r8, r0.zzzz, r6, r8
	mad r0, r0.wwww, r7, r8
	
	; row 2
	mul r8, r1.xxxx, r4
	mad r8, r1.yyyy, r5, r8
	mad r8, r1.zzzz, r6, r8
	mad r1, r1.wwww, r7, r8
	
	; row 3
	mul r8, r2.xxxx, r4
	mad r8, r2.yyyy, r5, r8
	mad r8, r2.zzzz, r6, r8
	mad r2, r2.wwww, r7, r8
	
	; row 4	
	mul r8, r3.xxxx, r4
	mad r8, r3.yyyy, r5, r8
	mad r8, r3.zzzz, r6, r8
	mad r3, r3.wwww, r7, r8					
	
	; pop from the stack
	mov r8, r100
ret
endfunc

; inversion of a 2x2 matrix
; matrix is stored in r0, result is given in r0, function uses r>100 as stack
;	r0: 
;		[ x  y ]
;		[ z w ]
;
; inverse:
;
;		[ w -y ]	           1
;					* ---------------
;		[ -z  x ]		x*w - y*z
func 2
	mov r100, r1 ; push r1 to the stack
	
	mul r1.xy, r0.xy00, r0.wz00 ; [x*w,y*z]
	sub r1.x, r1.x, r1.y ; x*w-y*z
	
	mov r0.x__w, r0.w00x ; x <-> w
	mov r0.yz, r0_neg(yz)
	div_zeroop(inf_else_max) r0, r0, r1.xxxx ; ./(x*w-y*z)
	
	mov r1, r100 ; pop r1 from the stack
ret
endfunc

; inversion of a 4x4 matrix
; matrix is stored in r0, r1, r2, r3, result is given in same registers, function uses r>100 as stack
;
;		[ r0.x  r0.y | r0.z r0.w ]
;		[ r1.x  r1.y | r1.z r1.w ]		[ A | B ]
;		------------------------------ =	--------- 
;		[ r2.x  r2.y | r2.z r2.w ]		[C  | D]
;		[ r3.x  r3.y | r3.z r3.w ]
;
; inverse:
;
;	
;		W := inv(D)
;		X := B*W
;		Y := W*C
;
;		IA := inv(A-X*C)
;		IB := -IA*X
;		IC := -Y*IA
;		ID := W-Y*IB
;
func 3
	mov r100, r4
	mov r101, r5
	mov r102, r6
	
	; C
	mov r4, r3.00xy
	mov r4.xy, r2.xy	
	
	; D
	mov r5, r3
	mov r5.xy__, r2.zw00
	
	mov r2, r4 ; r2 = C
	mov r3, r5 ; r3 = D
	
	; r4 = A
	mov r4, r1.00xy
	mov r4.xy, r0.xy
	
	; r5 = B
	mov r5, r1
	mov r5.xy__, r0.zw00
	
	; compute W = inv(D)
	mov r0, r3 ; D
	call 2
	mov r3, r0 ; r3 = W
	
	mov r1, r2 ; C
	call 0 ; W*C
	mov r6, r0 ; r6 = Y
	
	mov r0, r5 ; B
	mov r1, r3 ; W
	call 0
	mov r5, r0 ; r5 = X
	
	mov r1, r2 ; C
	call 0 ; r0 = X*C
	sub r0, r4, r0 ; r0 = A-X*C
	call 2
	mov r4, r0 ; r4 := IA
	
	mov r1, r5 ; X
	call 0 ; r0 := IA*X = -IB
	mov r5, r0_neg(xyzw) ; r5 = IB
	
	mov r0, r6 ; Y
	mov r1, r4 ; IA
	call 0 ; r0 = Y*IA
	mov r2, r0_neg(xyzw) ; r2 = IC

	mov r0, r6
	mov r1, r5
	call 0 ; r0 = Y*IB
	sub r3, r3, r0 ; r3 = ID = W-Y*IB
	
	; convert to original format
				
	mov r0.xy, r4.xy
	mov r0.__zw, r5.00xy
	
	mov r1, r5
	mov r1.xy__, r4.zw00
	
	mov r4, r2
	mov r5, r3
	
	mov r2.xy, r4.xy
	mov r2.__zw, r5.00xy
	
	mov r3, r5
	mov r3.xy__, r4.zw00
	
	; pop from the stack
	mov r4, r100
	mov r5, r101
	mov r6, r102	
ret
endfunc

; inversion of an 8x8 matrix
; matrix is stored in r6-r21  result is given in same registers, 
; function uses r>100 as stack
;
;		[ r6    r7   |  r10   r11 ]
;		[ r8    r9   |  r12   r13 ]
;		----------------------------
;		[ r14  r15 |  r18   r19 ]
;		[ r16  r17 |  r20   r21 ]
;
; inverse:
;
;		[ A | B ]
;		---------
;		[ C | D ]
;	
;		W := inv([r18-r21])
;		X := [r10-r13] * W
;		Y := W*[r14-r17]
;
;		A := inv([r6-r9] - X * [r14-r17])
;		B := -A*X
;		C := -Y*A
;		D := W-Y*B
;
func 4
	
	; push to the stack
	mov r100, r0
	mov r101, r1
	mov r102, r22
	mov r103, r23
	mov r104, r24
	mov r105, r25
	
	; compute W
	mov r2, r18
	mov r3, r19
	mov r4, r20
	mov r5, r21
	call 3 ; [r2-r5] = W = inv([r18-r21])
	
	mov r18, r2
	mov r19, r3
	mov r20, r4
	mov r21, r5	
	; [r18-r21] = W
	
	mov r0, r10
	mov r1, r11
	mov r2, r12
	mov r3, r13
	
	mov r4, r2
	mov r5, r3
	mov r6, r4
	mov r7, r5
	
	call 1 ; r0-r3 = X = [r10-r13] * W
	
	mov r10, r0
	mov r11, r1
	mov r12, r2
	mov r13, r3
	; [r10-r13] = X
	
	mov r0, r18
	mov r1, r19
	mov r2, r20
	mov r3, r21
	
	mov r4, r14
	mov r5, r15
	mov r6, r16
	mov r7, r17
	
	call 1 ; r0-r3 = Y = W*[r14-r17]
	
	mov r22, r0
	mov r23, r1
	mov r24, r2
	mov r25, r3
	; [r22-r25] = Y
	
	; pop from the stack
	mov r0, r100
	mov r1, r101
	mov r22, r102
	mov r23,  r103
	mov r24, r104
	mov r25, r105
ret
endfunc

end		
]]>
	</ILKernel>
	
</Kernels>