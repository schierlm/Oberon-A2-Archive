\documentclass[a4paper,11pt]{article}
\usepackage{color}
\usepackage{longtable}
\usepackage{amssymb,amsmath,graphicx}
\usepackage{nonfloat}
\usepackage{colortbl}
\usepackage{fancybox}
\usepackage{hyperref}
\usepackage{listings}

% --------------------------------- page layout --------------------------------------
\pagestyle{headings}
% other font styles:
%\usepackage[math]{iwona} % iwona, kurier
%\usepackage{cmbright}

\oddsidemargin -0 cm
\evensidemargin 0 cm
%\topmargin -1.5cm
\textwidth 16   cm
%\textheight 25 cm

\parskip 5pt
\parindent 0cm

\definecolor{lightgrey}{rgb}{0.5,0.5,0.5}
\definecolor{darkgrey}{rgb}{0.4,0.4,0.4}

% --------------------------------- listings --------------------------------------


\newcommand{\changefont}[3]{\fontfamily{#1}\fontseries{#2}\fontshape{#3}\selectfont}

\newcommand{\progfont}{\changefont{pcr}{m}{n}}
\newcommand{\kwfont}{\changefont{pcr}{b}{n}}
\renewcommand{\lstlistingname}{Fig.}
\newcommand{\todo}[1]
            {\setlength{\fboxrule}{2pt}\fcolorbox{red}{yellow}{\begin{minipage}{\textwidth} \color{blue}$todo:$ #1 \end{minipage}}}

\newcommand{\pc}[1]{\makebox{\progfont #1}}
\newcommand{\kw}[1]{\makebox{\kwfont #1}}

\lstdefinelanguage{ebnf}[]{}
{morekeywords={},
sensitive=true,
comment=[l]{//},
comment=[s]{(*}{*)},
morestring=[b]',
morestring=[b]",
}
\lstdefinelanguage{Oberon}[]{Pascal}%
  {morekeywords={len,module,import},%
   sensitive=f,%
    morecomment=[s][\color{red}]{(*!}{!*)}
  }[keywords]%
\lstset{language=Oberon,
basicstyle=\small\progfont,keywordstyle=\kwfont ,identifierstyle=\progfont,
commentstyle=\color{darkgrey}, stringstyle=, showstringspaces=false, %keepspaces=true,
numbers=none, numberstyle=\tiny, stepnumber=1, numbersep=5pt, captionpos=b,
columns=flexible % flexible, fixed, fullflexible
framerule=1mm,frame=shadowbox, rulesepcolor=\color{blue}, % frame = shadowbox
xleftmargin=2mm,xrightmargin=2mm,
}
\renewcommand{\lstlistingname}{Fig.}

\begin{document}
\title{A2 Programming Quickstart Guide\\[1em] \normalsize A Very Short Introduction into Programming on A2 with Active Oberon}
\author{Sven Stauber, Florian Negele, Ulrike Glavitsch, Felix Friedrich}
\maketitle

\tableofcontents
% --------------------------------------------------------------------------------
\subsection*{Objective}
This is a small introduction to the programming language Oberon and the operating / runtime system A2. This introduction does not replace a language report, neither is it an introduction to programming. It rather should provide a fast access to the used operating system and programming language by ways of comments and examples. It has been prepared for the Operating System Course, Spring Semester 2009 at ETH Zurich as accompanying material for the practial exercises.

\section{The Operating System A2 and the Language Active Oberon}
\subsection{A2 and Active Oberon}
A2 is a modern, multi-threaded operating system in the tradition of the ETH operating systems Medos, Oberon and Aos. It is completely written in Active Oberon with only very few exceptions: little parts of the kernel and some low-level optimized routines are implemented in in-line assembler. A2 does not use heavyweight processes but is rather composed of light-weight processes (`threads') that are supported by {\em Active Objects} in the language Active Oberon. Active Oberon is a highly readable, abstract programming language. Its abstraction protects programmers from artificial technical complexities while system-near programming is still possible by ways of a special `system' module. The interplay of an abstract language and efficient runtime accounts for the special flavour of A2.

\subsection{Modules and Commands}
Oberon is a modular programming language that is supported by a dynamic loading concept in the operating system A2. The role of programs and applications is played by {\em modules}. Instead of loading and executing a `program', {\em modules} are loaded and {\em commands} are executed. Once a module is loaded, it stays loaded until it is explicitly unloaded or until the system goes down. Before we give more details on modules and commands, we show an example of a very simple Oberon module:

\begin{lstlisting}[language=Oberon,frame=none,caption=A simple Oberon Module]
MODULE Hello;

IMPORT Commands;

    PROCEDURE World*(context: Commands.Context);
    BEGIN
        context.out.String("Hello World");
        context.out.Ln
    END World;

END Hello.
\end{lstlisting}

Commands are executed by activating a command string of the form \verb+ModuleName.CommandName+ within any text displayed on the screen. In the simple example above, this would be \verb+Hello.World+. A command is usually activated by a middle-mouse click or by selecting the command string and using the key-combination \verb|Ctrl+Return|. When a command is activated, the module with name \verb+ModuleName+ is dynamically loaded on demand and the program counter (potentially of a newly created process) is set to the loaded procedure named \verb+CommandName+ in module \verb+ModuleName+.

Note that a module name has nothing to do with the name of the file that contains the source code of the module. It is pure convention that source code files are denominated as \verb+ModuleName.Mod+.

An Active Oberon module consists of {\em constants}, {\em variables}, {\em types} and {\em procedures}. Procedures contain executable code. A procedure may or may not accept parameters and a procedure may or may not return a parameter. A procedure can act as a command if and only if
\begin{itemize}
\item it is exported and
\item it provides no return parameter and
\item it provides at most one input parameter of type \verb+Commands.Context+
\item it is declared immediately in the module scope
\end{itemize}

The following example module contains examples of procedures that can or cannot act as commands. Note that comments in Oberon are embraced by \verb+(*+ and \verb+*)+.
\begin{lstlisting}[language=Oberon,frame=none,caption=Procedures and Commands]
MODULE Sample;

IMPORT Commands, KernelLog;

    (* Simple is a command, "*" indicates that Simple is exported *)
    PROCEDURE Simple*;
    BEGIN KernelLog.String("SimpleOutput called"); KernelLog.Ln;
    END Simple;

    (* Internal is not a command: it is not marked exported *)
    PROCEDURE Internal;
    BEGIN KernelLog.String("InternalOutput called"); KernelLog.Ln;
    END Internal;

    (* WithContext is a valid command *)
    PROCEDURE WithContext*(context: Commands.Context);
    BEGIN
        context.out.String("this is written to the standard output stream");
        context.out.Ln;
    END WithContext;

    (* WithOther is not a command: parameter type is not Commands.Context *)
    PROCEDURE WithOther*(VAR x: REAL);
    BEGIN x := 2*x
    END WithOther

    (* WithReturn is not a command as it provides a return value *)
    PROCEDURE WithReturn*(): LONGINT;
    BEGIN RETURN 10
    END WithReturn;

END Sample.
\end{lstlisting}

After compilation of the module \verb+Sample+, the commands \verb+Sample.Simple+ and \verb+Sample.WithContext+ can be activated. The attempt to activate \verb+Sample.Internal+, \verb+Sample.WithOther+ or \verb+Sample.WithReturn+ will fail with a short error message on the kernel log.

\subsection{Loading and Unloading Modules}
When a module is compiled, an {\em object file} is generated and is made persistent in a file. It is not immediately loaded.
Basically, a module \verb+M+ is loaded when a command of the form \verb+M.CommandName+ is activated.\footnote{The loading of a module M takes place independent of the string M.C being a valid command or not.} Additionally, modules are automatically loaded by the system when a module is loaded that imports them (cf.~ Paragraph \ref{Imports}).

Once a module \verb+A+ has been loaded, any call of a valid command \verb+A.C+ will execute the loaded code and will not result in re-loading \verb+A+. The reason is clear: other modules may rely on information being provided globally in module \verb+A+ or \verb+A+ may contain state information that should not be removed after one call. Consider the following example:

\begin{lstlisting}[language=Oberon,frame=none,caption=A simple Oberon Module]
MODULE Hello;

IMPORT KernelLog;

    PROCEDURE World*;
    BEGIN KernelLog.String("Hello World"); KernelLog.Ln;
    END World;

BEGIN
    (* this is a special `procedure': the module body
      it is executed once a module has been freshly loaded *)
    KernelLog.String("Hello has been loaded"); KernelLog.Ln;
END Hello.
\end{lstlisting}

The module body will be executed once after the module has been loaded but prior to any of its commands. Thus, a first call of \verb+Hello.World+ will result in the output \pc{Hello has been loaded} and \pc{Hello World} in the kernel log. Each subsequent call will result in an output of \pc{Hello World}, but no further execution of the body. Only if the module has been unloaded, the body is executed again. Note that, consequently, in order to see the effects of a modification and re-compilation of a module it has to be unloaded.

Modules can be unloaded explicitly with the command \verb+SystemTools.Unload ModuleNames ~+ where \verb+ModuleNames+ is a white space separated list of module names and `\verb+~+' indicates the end of the list. Note that a module \verb+A+ can only be unloaded if no other currently loaded module imports \verb+A+.


\section{Parts of an Active Oberon Module}
An Active Oberon Module consists of the following parts
\begin{itemize}
\item an import list,
\item a constant declarations section,
\item a type declarations section,
\item a variable declarations section and
\item a procedure declarations section.
\end{itemize}
Before we describe each of the sections in more detail, let us start with a little example module.

\begin{lstlisting}[language=Oberon,frame=none,caption={A useless module containing constants, types, variables and procedures}]
MODULE Simple;

(*-------------     import list       ------------*)
 IMPORT KernelLog, Commands, Streams;

(*------------- constant declarations ------------*)
CONST
    a*=100;
    s="a string";

(*--------------  type declarations   ------------*)
TYPE
    MyNumberType = LONGINT;
    MyRecordType* = POINTER TO RECORD a*,b,c: LONGINT END;

(*------------- variable declarations ------------*)
VAR
    globalObject: MyObjectType; x: INTEGER;

(*------------- procedure declarations -----------*)
PROCEDURE Modify(t: MyRecordType);
BEGIN t.a := 10; t.b := 20; t.c := 30;
END Modify;

(* an exported procedure *)
PROCEDURE Display*(stream: Streams.Stream; t: MyRecordType);
BEGIN
    stream.Int(t.a,10);
    stream.Int(t.b,10);
    stream.Int(t.c,10);
END Display;

(* a valid command *)
PROCEDURE Test*(context: Commands.Context);
VAR t: MyRecordType;
BEGIN Modify(t); Display(context.out,t);
END Test;

BEGIN (* the module body *)
    KernelLog.String("Simple Started"); KernelLog.Ln;
END Simple.
\end{lstlisting}

\subsection{Imports and Exported Symbols} \label{subsection:Imports}
The exported symbols of a module can be made available to other modules. To make the symbols of module \verb+A+ available in module \verb+B+, module \verb+A+ has to be imported in module \verb+B+. A module import graph is a directed graph where cycles are forbidden. This is checked by the compiler.

Symbols in one module that are to be used in any other module must be exported. A symbol is exported by suffixing the name with an asterisk `\verb+*+'. It is exported read only by suffixing with a minus symbol `\verb+-+'. We provide a little example of a module \verb+A+ being imported by a module \verb+B+.

\begin{lstlisting}[language=Oberon,frame=none,caption={B imports A}]
MODULE A;
    CONST exportedConst*=100;
END A.

MODULE B;
    IMPORT A;
    VAR c: LONGINT;
BEGIN
    c := A.exportedConst;
END B.
\end{lstlisting}

\subsection{Constant Declarations}
Static values can be used directly in expressions as, for example, in \verb~a := 3+b~. To support better maintainable and readable code, it is possible to associate an identifier with a constant expression, in other words: to {\em declare a constant}. In Active Oberon, only values of basic type and strings can be declared as constant\footnote{There are exceptions: special mathematical arrays can also be declared as constants.}. The following module contains some examples.

\begin{lstlisting}[language=Oberon,frame=none,caption={Declaration and Usage of Constants}]
MODULE A;

CONST
    (* ---------------------- global constants ----------------------- *)
    someInteger* = 800; (* exported *)
    anotherInteger= someInteger + 1; (* constant expression *)
    someReal = 4.44E-5;
    anotherReal* = 5.5; (* exported *)
    someString = "This is a string";
    max       = 2147483647;
    allbits   = 7FFFFFFFH; (* hex number *)
    step      = 7;

VAR
    (* ----------------------- global variable ----------------------- *)
    Z: LONGINT;

    PROCEDURE Rand*(): LONGINT;
    (* constants can also be declared in procedure scope: *)
    CONST a = 16807; q = 127773; r = 2836;
    VAR t: LONGINT;
    BEGIN
        t := a * (Z MOD q) - r * (Z DIV q);
        IF t > 0 THEN Z := t ELSE Z := t + max END;
        RETURN Z;
    END Rand;
BEGIN
    Z := someInteger;
END A.
\end{lstlisting}

\subsection{Type Declarations}
Type declarations bind an identifier to a type. On the one hand, a type declaration can provide an alias to another type including built-in (basic) types, such as integer, real, character etc. On the other hand, a type declaration can provide a {\em binding of an identifier to a custom form of representation} (usually a composite type). However, type declarations go beyond a mere convenience: in Active Oberon two variables are not necessarily of the same type, if their representation coincide. Before we provide the syntax of type declaration, have a short glance at the following example:
\begin{lstlisting}[language=Oberon,frame=none,caption={Incompatible types}]
MODULE Test;
VAR
    x: RECORD a,b: INTEGER END;
    y: RECORD a,b: INTEGER END;
BEGIN
    x := y; (* THIS WILL NOT COMPILE *)
END Test;
\end{lstlisting}
Although in the previous example the variables \verb+x+ and \verb+y+ are declared as types with a compatible structure, they are not allowed to be assigned as their types are not the same. The following example will provide a solution of this `dilemma':
\begin{lstlisting}[language=Oberon,frame=none,caption={Same Types}]
MODULE Test;
VAR
    x,y: RECORD a,b: INTEGER END;
BEGIN
    x := y; (* x and y are of the same type, thus assignment compatible *)
END Test;
\end{lstlisting}
Now, assume that variables \verb+x+ and \verb+y+ were declared in different scopes, then such a solution would not be possible any more and then type declarations are a must. In the following example, a type declaration is used instead of an immediate formulation in the variable declaration:
\begin{lstlisting}[language=Oberon,frame=none,caption={Using type declarations}]
MODULE Test;
TYPE
MyRecord = RECORD a,b: INTEGER END;

VAR
x: MyRecord;

PROCEDURE Print(m: MyRecord);
BEGIN
    KernelLog.Int(x,10); KernelLog.Int(y,10); KernelLog.Ln;
END Print;

BEGIN
    Print(x)
END Test;
\end{lstlisting}
Note that the call of procedure \verb+Print+ with variable \verb+x+ requires that \verb+x+ is assignment compatible to the respective parameter (which is the case, as \verb+x+ and \verb+m+ are of the same type).

Two types are of the same type, if they are provided by the same qualified identifier, or if one is an (immediate or indirect) alias of the other. Examples:
\begin{lstlisting}[language=Oberon,frame=none,caption={Same and different types}]
TYPE
Number=REAL; (* same type as REAL and Float *)
Float =REAL; (* same type as REAL and Number *)
MyRecord = RECORD a,b: INTEGER END;  (* same as MyAlias and AnotherAlias *)
AnotherRecord = RECORD a,b: INTEGER END; (* no same type available *)
MyAlias = MyRecord; (* same as MyRecord and AnotherAlias *)
AnotherAlias = MyAlias; (* same as MyAlias and MyRecord *)
\end{lstlisting}

We will introduce the basic and composite types in more details in sections \ref{section:BasicTypes} and \ref{section:CompositeTypes}

\subsection{Variable and Parameter Declarations}
In Active Oberon, variables have to be declared before use in a variable declaration section. A variable declaration consists of an identifier and a type. Variables can be declared globally, in a procedure scope, in an object or in a record scope. Parameters are variables that refer to expressions that have been passed to the procedure from its caller. Parameters are declared in the head of the procedure declaration.
 
Parameters can be {\em value parameters}, in which case they represent the actual value of an expression being passed to the respective procedure. Or parameters can be {\em variable parameters}, in which case they stand for the reference of a designator that has been passed to the procedure. The modification of a value parameter within a procedure does only have a temporary effect within the procedure while the modification of a variable parameter implies the modification of the passed variable.

We illustrate the concepts in the following example. 

\begin{lstlisting}[language=Oberon,frame=none,caption={Variables and Parameters}]
MODULE Variables; 
TYPE
    (* variables in a record *) 
    Pair=RECORD x,y: REAL END; 
    PairPointer = POINTER TO Pair; 
    
VAR (* global variables *) 
    a: LONGINT; 
    b: Pair;
    c: PairPointer; 

PROCEDURE Square(x: REAL): REAL;
BEGIN x := x*x; RETURN x
END Square; 

PROCEDURE SetValues(VAR p:Pair; x,y: REAL);  
BEGIN p.x := x; p.y := y
END SetValues;

PROCEDURE SetValuesP(p:PairPointer; x,y: REAL);
BEGIN p.x := x; p.y := y
END SetValuesP;

BEGIN 
    a := 10; 
    SetValues(b,a,Square(a)); 
    NEW(c); 
    SetValues(c^,a,Square(a));
    SetValuesP(c,a,Square(a)); 
END Variables; 
\end{lstlisting}

\subsection{Procedure Declarations}
Procedures can be declared in a module scope, within procedure scopes (`nested procedures') and in object scopes:
\begin{lstlisting}[language=Oberon,frame=none,caption={Procedures}]
MODULE Procedures; 

TYPE 
    O = OBJECT
    
    PROCEDURE Method; 
        PROCEDURE NestedProcedure;
        BEGIN 
        END NestedProcedure;
    BEGIN 
    END Method; 
    
    END O; 

PROCEDURE GlobalProcedure; 
    PROCEDURE NestedProcedure; 
    BEGIN END NestedProcedure; 
END GlobalProcedure; 

END Procedures; 
\end{lstlisting}

\section{Basic Types}\label{section:BasicTypes}
There are nine predeclared basic types in Active Oberon. Their names and valid values are the following:

\begin{itemize}
\item BOOLEAN the truth values TRUE and FALSE.
\item CHAR the characters of the extended ASCII set (0X ... 0FFX).
\item SHORTINT the integers between MIN(SHORTINT) and MAX(SHORTINT).
\item INTEGER the integers between MIN(INTEGER) and MAX(INTEGER).
\item LONGINT the integers between MIN(LONGINT) and MAX(LONGINT).
\item HUGEINT the integers between MIN(HUGEINT) and MAX(HUGEINT).
\item REAL real numbers between MIN(REAL) and MAX(REAL).
\item LONGREAL real numbers between MIN(LONGREAL) and MAX(LONGREAL).
\item SET the sets of integers between 0 and MAX(SET).
\end{itemize}

\subsection{The types SHORTINT, INTEGER, LONGINT and HUGEINT}\label{subsection:IntegerTypes}
These four types comprise the {\em integer types}. They represent the integer numbers and differ by the cardinality of the set of random numbers represented by each type. The need for different types arises from the architecture of machines which - for reasons of efficiency - provide various word formats with corresponding machine instructions.

\subsection{The types REAL and LONGREAL} \label{subsection:RealTypes}
The real types approximate the real numbers. Each element from the set of REAL or LONGREAL is a representative of an interval of genuine real numbers. Variables of a real type are represented by pairs of integers, a {\em mantissa} and an {\em exponent}. This is called {\em floating-point} representation. The two types are distinguished by the number of digits of the mantissa (fractional part) and the exponent. As with the integer types, {\em overflow} may occur and result in termination of the program.

Floating point numbers are only an approximation to the real numbers of mathematics. As a consequence computations involving floating-point values are inexact because each operation may be subject to truncation. The resulting problems are well investigated and treated in every text on numerical mathematics.

\subsection{Hierarchy of the numeric types} \label{subsection:HierarchyNumericTypes}
The {\em numeric types} are comprised of the integer and real types and form a set hierarchy

$LONGREAL \supseteq REAL \supseteq HUGEINT \supseteq LONGINT \supseteq INTEGER \supseteq SHORTINT$

The range of the larger type includes the ranges of the smaller types. For example, REAL {\em includes} HUGEINT \ldots SHORTINT. The smaller type is said to be {\em compatible} with the larger one in the sense that it can without danger of loss of leading digits be converted. In most cases, such a conversion is also exact. In assignments and in expansions the conversion of internal representations is automatic.

\subsection{The type BOOLEAN} \label{subsection:BooleanType}
A Boolean value is one of the {\em logical truth values} which are represented in Active Oberon by the standard identifiers TRUE and FALSE.

\subsection{The type SET} \label{subsection:SetType}
The values which belong to the type SET are {\em elements of the power set of} $[0, 1, \ldots, N]$ where $N$ is equal to MAX(SET). $N$ is a constant defined by the implementation. It is typically the word length of the computer (or a small multiple of it). In fact, sets are efficiently implemented as bit operations.

Examples of set constants are:
\begin{lstlisting}[language=Oberon,frame=none]
{}, {1, 6, 10}, {0, 2..4, 8}
\end{lstlisting}

where \verb+{}+ denotes the empty set and the subset \verb+2..4+ refers to the elements 2, 3 and 4.

\subsection{The type CHAR}
A major portion of the input and output of computers is in the form of character strings that contain values of type CHAR. The value range of the type CHAR consists of the characters of the roman alphabet and a small set of special symbols used frequently in commerce and mathematics.

The set representing the type CHAR is ordered and each character has a fixed position or {\em ordinal number}. This is reflected in the notation for character constants which may be written as "a" or 61X for the letter a. The first representation denotes the value of the variable of type CHAR, the second its (hexadecimal) {\em ordinal} number.

\section{Composite Types}\label{section:CompositeTypes}

In Active Oberon, there are three composite types available. Arrays, Records and Pointers. 

\subsection{Arrays}
Arrays can be declared static, open or dynamic. Static arrays are declared as ARRAY number OF BaseType, where number must be constant. The BaseType can be an array, which allows expressions like ARRAY 12 OF ARRAY 13 OF ARRAY 11 OF REAL. Arrays can be declared open only in a parameter section. Open arrays are declared as ARRAY OF ...  Dynamic arrays are basically references pointing to an array with lengths that may be provided during runtime. They are declared as POINTER TO ARRAY OF ...
\begin{lstlisting}[language=Oberon,frame=none]
VAR 
a: ARRAY 32 OF ARRAY 20 OF INTEGER; (* static *)
b: POINTER TO ARRAY OF ARRAY OF REAL; (* dynamic *)
    
PROCEDURE Print(x: ARRAY OF CHAR); (* open *) 
END Print; 
\end{lstlisting}   

\subsection{Records}
Records are containers of data. Records are value types and are declared as RECORD (variables) END. Records can also be declared as reference types using POINTER TO. Record data are referred to via recordName.variableName.
\begin{lstlisting}[language=Oberon,frame=none]
VAR
a: RECORD x,y: LONGINT END; 
p: POINTER TO RECORD a,b: REAL END; 
...
BEGIN 
...
NEW(p); 
p.x := a.x;
....
\end{lstlisting}    

\subsection{Objects}
Objects are basically reference records that can additionally be equipped with procedures. Procedures in an object are methods: they reside in the object scope and have access to the object's variables. An object is a reference type and can be explicitly referred to in its method using the SELF identifier.
\begin{lstlisting}[language=Oberon,frame=none]
TYPE 
MyObject = OBJECT (* class *) 
VAR x,y: REAL; 

PROCEDURE Equals(o: MyObject): BOOLEAN; 
BEGIN 
    IF o = SELF THEN RETURN TRUE
    ELSE RETURN (o.x = x) & (o.y = y)
    END; 
END Equals; 

END MyObject; 

VAR p,q: MyObject; (* objects / instances *) 
...

BEGIN 
    NEW(p); p.x := 10; p.y := 10; 
    ...
    IF p.Equals(q) THEN ...
    END; 
\end{lstlisting}

\subsection{Inheritance}
Active Oberon is an object oriented language. For both, records and objects, inheritance is supported by Oberon. It is possible to extend records and objects and to use type checks, type guards and overloading of methods. 
Record and object extension is declared as in the following example:

\begin{lstlisting}[language=Oberon,frame=none]
TYPE

Rectangle = RECORD
    x,y,w,h: INTEGER
END

FilledRectangle= RECORD(Rectangle)
    color: INTEGER
END;

Window = OBJECT
VAR x,y,w,h: INTEGER; 

    PROCEDURE Print; 
    BEGIN 
        (* draw frame *) 
    END Print; 
END Window; 

FilledWindow = OBJECT (Window) 
VAR color: INTEGER; 
    
    PROCEDURE Print; (* overwrites Window.Print *) 
    BEGIN 
        Print^; (* supercall *) 
        (* fill *) 
    END Print; 
END FilledWindow; 

\end{lstlisting}


\section{Active Objects}

\section{In- and Output}

\section{The module System}

\section{Active Oberon EBNF}



% --------------------------------------- examples -------------------------------
\newpage {\Huge EXAMPLES}
\section{Section}
\subsection{Subsection}
\subsubsection{SubSubSection}
\paragraph{Paragraph}

Example Listing EBNF
\begin{lstlisting}[language=ebnf]
Number       =  Integer | Real.
Integer      =  Digit {Digit} | Digit {HexDigit} 'H'.
Real         =  Digit {Digit} '.' {Digit} [ScaleFactor].
ScaleFactor  =  ('E' | 'D') ['+' | '-'] digit {digit}.
HexDigit     =  Digit | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'.
Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
\end{lstlisting}

Example Listing EBNF no frame
\begin{lstlisting}[language=ebnf,frame=none]
Number       =  Integer | Real.
Integer      =  Digit {Digit} | Digit {HexDigit} 'H'.
\end{lstlisting}


Example Listing Oberon
\begin{lstlisting}[language=Oberon]
    MODULE Test;
    PROCEDURE Test;
    VAR a,b,c: LONGINT;
    BEGIN
        a := b*b (* b is not initialized *)
    END Test;
    END Test.
\end{lstlisting}

Example Listing Oberon no frame with line numbers
\begin{lstlisting}[language=Oberon,frame=none,numbers=left]
    MODULE Test; (* module in upper case *)
    PROCEDURE Test;
    VAR a,b,c: LONGINT;
    BEGIN
        a := b*b
    END Test;
    END Test.
\end{lstlisting}

Example Listing Oberon NoFrame
\begin{lstlisting}[language=Oberon,frame=none]
    module Test; (* module in lower case *)
    procedure Test;
    var a,b,c: longint;
    begin
        a := b*b
    end Test;
    end Test.
\end{lstlisting}

Oberon keyword \kw{module} in text.

Oberon programming content \verb+a := b*b+ in text.

Math content $x \leftarrow 10$ in text.

Math content alone:
$$x \leftarrow 10$$




\end{document}

