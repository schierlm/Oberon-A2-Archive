\documentclass[a4paper,11pt]{article}
\usepackage{color}
\usepackage{longtable}
\usepackage{amssymb,amsmath,graphicx}
\usepackage{nonfloat}
\usepackage{colortbl}
\usepackage{fancybox}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xspace}

% --------------------------------- page layout --------------------------------------
\pagestyle{headings}
% other font styles:
%\usepackage[math]{iwona} % iwona, kurier
%\usepackage{cmbright}

\oddsidemargin -0 cm
\evensidemargin 0 cm
%\topmargin -1.5cm
\textwidth 16   cm
%\textheight 25 cm

\parskip 5pt
\parindent 0cm

\definecolor{lightgrey}{rgb}{0.5,0.5,0.5}
\definecolor{darkgrey}{rgb}{0.4,0.4,0.4}

% --------------------------------- listings --------------------------------------

\newcommand{\changefont}[3]{\fontfamily{#1}\fontseries{#2}\fontshape{#3}\selectfont}

\newcommand{\progfont}{\changefont{pcr}{m}{n}}
\newcommand{\kwfont}{\changefont{pcr}{b}{n}}
\renewcommand{\lstlistingname}{Fig.}
\newcommand{\todo}[1]{\setlength{\fboxrule}{2pt}\fcolorbox{red}{yellow}{\begin{minipage}{\textwidth} \color{blue}$todo:$ #1 \end{minipage}}}

\newcommand{\pc}[1]{\makebox{\progfont #1}}
\newcommand{\kw}[1]{\makebox{\kwfont #1}}
\newcommand{\AZ}{\textsl{A2}\xspace}

\lstdefinelanguage{ebnf}[]{}
{morekeywords={},
sensitive=true,
comment=[l]{//},
comment=[s]{(*}{*)},
morestring=[b]',
morestring=[b]",
}
\lstdefinelanguage{Oberon}[]{Pascal}%
  {morekeywords={len,module,import},%
   sensitive=f,%
    morecomment=[s][\color{red}]{(*!}{!*)}
  }[keywords]%
\lstset{language=Oberon,
basicstyle=\small\progfont,keywordstyle=\kwfont ,identifierstyle=\progfont,
commentstyle=\color{darkgrey}, stringstyle=, showstringspaces=false, %keepspaces=true,
numbers=none, numberstyle=\tiny, stepnumber=1, numbersep=5pt, captionpos=b,
columns=flexible % flexible, fixed, fullflexible
framerule=1mm,frame=shadowbox, rulesepcolor=\color{blue}, % frame = shadowbox
xleftmargin=2mm,xrightmargin=2mm,
}
\renewcommand{\lstlistingname}{Fig.}


\begin{document}
\title{\AZ Programming Quickstart Guide}
\author{Felix Friedrich, Ulrike Glavitsch, Florian Negele, Sven Stauber}
\maketitle

This is a small introduction to the programming language Oberon and the operating / runtime system \AZ. This introduction does not replace a language report, neither is it an introduction to programming. It rather should provide a fast access to the used operating system and programming language by ways of comments and examples. It has been prepared for the Operating System Course, Spring Semester 2009, at ETH Zurich as accompanying material to the practical exercises.



\tableofcontents


\section{The Operating System \AZ}
\AZ is a modern, multi-threaded operating system in the tradition of the ETH operating systems Medos, Oberon and Aos. It is completely written in Active Oberon with only very few exceptions: little parts of the kernel and some low-level optimized routines are implemented in in-line assembler. \AZ is composed of light-weight processes that are supported by {\em Active Objects} in the language Active Oberon. Active Oberon is a highly readable, abstract programming language. Its abstraction protects programmers from artificial technical complexities while system-near programming is still possible by ways of a special `system' module. The interplay of an abstract language and efficient runtime accounts for the special flavour of \AZ.

\subsection{Modules and Commands}
Oberon is a modular programming language that is supported by a dynamic loading concept in the operating system \AZ. The role of programs and applications is played by {\em modules}. Instead of loading and executing a `program', {\em modules} are loaded and {\em commands} are executed. Once a module is loaded, it stays loaded until it is explicitly unloaded or until the system goes down. Before we give more details on modules and commands, we show an example of a very simple module. Note that comments are embraced by \verb+(*+ and \verb+*)+.

\begin{lstlisting}[language=Oberon,frame=none,caption=A simple Oberon Module]
MODULE Hello;

IMPORT Commands, KernelLog;

    (* a command taking a context parameter *) 
    PROCEDURE World*(context: Commands.Context);
    BEGIN
        context.out.String("Hello World");
        context.out.Ln
    END World;
    
    (* a command without context *) 
    PROCEDURE InnerWorld*;
    BEGIN 
        KernelLog.String("Hello Kernel World"); 
        KernelLog.Ln; 
    END InnerWorld; 

END Hello.
\end{lstlisting}

Commands are executed by activating a command string of the form \verb+ModuleName.CommandName+ within any text displayed on the screen. In the simple example above, this would be \verb+Hello.World+ and \verb+Hello.InnerWorld+. A command is usually activated by a middle-mouse click or by selecting the command string and using the key-combination \verb|Ctrl+Return|. When a command is activated, the module with name \verb+ModuleName+ is dynamically loaded on demand and the program counter (potentially of a newly created process) is set to the loaded procedure named \verb+CommandName+ in module \verb+ModuleName+.

Note that a module name has nothing to do with the name of the file that contains the source code of the module. It is pure convention that source code files are denominated as \verb+ModuleName.Mod+.

\subsection{Loading and Unloading Modules}
When a module is compiled, an {\em object file} is generated and is made persistent in a file. It is not immediately loaded.
Basically, a module \verb+M+ is loaded when a command of the form \verb+M.CommandName+ is activated. Additionally, a module X is automatically loaded by the system when a module Y is loaded that imports X (cf.~ Paragraph \ref{Imports}).

Once a module \verb+A+ has been loaded, any call of a valid command \verb+A.C+ will execute the loaded code and will not result in re-loading \verb+A+. The reason is clear: other modules may rely on information being provided globally in module \verb+A+ or \verb+A+ may contain state information that should not be removed after one call. Consider the following example:

\begin{lstlisting}[language=Oberon,frame=none,caption=A simple Oberon Module]
MODULE Hello;

IMPORT KernelLog;

    PROCEDURE World*;
    BEGIN KernelLog.String("Hello World"); KernelLog.Ln;
    END World;

BEGIN
    (* this is a special `procedure': the module body
      it is executed once a module has been freshly loaded *)
    KernelLog.String("Hello has been loaded"); KernelLog.Ln;
END Hello.
\end{lstlisting}

The module body will be executed once after the module has been loaded but prior to any of its commands. Thus, a first call of \verb+Hello.World+ will result in the output \pc{Hello has been loaded} and \pc{Hello World} in the kernel log. Each subsequent call will result in an output of \pc{Hello World}, but no further execution of the body. Only if the module has been unloaded, the body is executed again. Note that, consequently, in order to see the effects of a modification and re-compilation of a module it has to be unloaded.

Modules can be unloaded explicitly with the command 
\begin{center}
\verb+SystemTools.Free ModuleNames ~+ 
\end{center}
where \verb+ModuleNames+ is a white space separated list of module names and `\verb+~+' indicates the end of the list. Note that a module \verb+A+ can only be unloaded if no other currently loaded module imports \verb+A+.

\section{The Language Active Oberon}

\subsection{Parts of a Module}
An Active Oberon Module consists of an import list, constant declarations, type declarations, variable declarations, procedure declarations and a body, all optionally. In this Section, we describe these parts 

\begin{lstlisting}[language=Oberon,frame=none,caption={A useless module containing constants, types, variables and procedures}]
MODULE Simple;

(*-------------     import list       ------------*)
 IMPORT KernelLog, Commands, Streams;

(*------------- constant declarations ------------*)
CONST
    a*=100;
    s="a string";

(*--------------  type declarations   ------------*)
TYPE
    MyNumberType = LONGINT;
    MyRecordType* = POINTER TO RECORD a*,b,c: LONGINT END;

(*------------- variable declarations ------------*)
VAR
    globalObject: MyObjectType; x: INTEGER;

(*------------- procedure declarations -----------*)
PROCEDURE Modify(t: MyRecordType);
BEGIN t.a := 10; t.b := 20; t.c := 30;
END Modify;

(* an exported procedure *)
PROCEDURE Display*(stream: Streams.Stream; t: MyRecordType);
BEGIN
    stream.Int(t.a,10);
    stream.Int(t.b,10);
    stream.Int(t.c,10);
END Display;

(* a valid command *)
PROCEDURE Test*(context: Commands.Context);
VAR t: MyRecordType;
BEGIN Modify(t); Display(context.out,t);
END Test;

BEGIN (* the module body *)
    KernelLog.String("Simple Started"); KernelLog.Ln;
END Simple.
\end{lstlisting}

\subsubsection{Import List} \label{section:ImportList}
The exported symbols of a module can be made available to other modules. To make the symbols of module \verb+A+ available in module \verb+B+, module \verb+A+ has to be imported in module \verb+B+. A module import graph is a directed graph where cycles are forbidden. This is checked by the compiler.

Symbols in one module that are to be used in any other module must be exported. A symbol is exported by suffixing the name with an asterisk `\verb+*+'. It is exported read only by suffixing with a minus symbol `\verb+-+'. We provide a little example of a module \verb+A+ being imported by a module \verb+B+.

\begin{lstlisting}[language=Oberon,frame=none,caption={B imports A}]
MODULE A;
    CONST exportedConst*=100;
END A.

MODULE B;
    IMPORT A;
    VAR c: LONGINT;
BEGIN
    c := A.exportedConst;
END B.
\end{lstlisting}

\subsubsection{Constant Declaration Section}\label{section:ConstantDeclarationSection}
Static values can be used directly in expressions as, for example, in \verb~a := 3+b~. To support better maintainable and readable code, it is possible to associate an identifier with a constant expression, in other words: to {\em declare a constant}. In Active Oberon, only values of basic type and strings can be declared as constant\footnote{There are exceptions: special mathematical arrays can also be declared as constants but this goes beyond the scope of this short reference.}. The following module contains some examples.

\begin{lstlisting}[language=Oberon,frame=none,caption={Declaration and Usage of Constants}]
MODULE A;

CONST
    (* ---------------------- global constants ----------------------- *)
    someInteger* = 800; (* exported *)
    anotherInteger= someInteger + 1; (* constant expression *)
    someReal = 4.44E-5;
    anotherReal* = 5.5; (* exported *)
    someString = "This is a string";
    max       = 2147483647;
    allbits   = 7FFFFFFFH; (* hex number *)
    step      = 7;

VAR
    (* ----------------------- global variable ----------------------- *)
    Z: LONGINT;

    PROCEDURE Rand*(): LONGINT;
    (* constants can also be declared in procedure scope: *)
    CONST a = 16807; q = 127773; r = 2836;
    VAR t: LONGINT;
    BEGIN
        t := a * (Z MOD q) - r * (Z DIV q);
        IF t > 0 THEN Z := t ELSE Z := t + max END;
        RETURN Z;
    END Rand;
BEGIN
    Z := someInteger;
END A.
\end{lstlisting}

\subsubsection{Type Declaration Section}\label{section:TypeDeclarationSection}
Type declarations bind an identifier to a type. On the one hand, a type declaration can provide an alias to another type including built-in (basic) types, such as integer, real, character etc. On the other hand, a type declaration can provide a {\em binding of an identifier to a custom form of representation} (usually a composite type). However, type declarations go beyond a mere convenience: in Active Oberon two variables are not necessarily of the same type, if their representation coincide. Before we provide the syntax of type declaration, have a short glance at the following example:
\begin{lstlisting}[language=Oberon,frame=none,caption={Incompatible types}]
MODULE Test;
VAR
    x: RECORD a,b: INTEGER END;
    y: RECORD a,b: INTEGER END;
BEGIN
    x := y; (* THIS WILL NOT COMPILE *)
END Test;
\end{lstlisting}
Although in the previous example the variables \verb+x+ and \verb+y+ are declared as types with a compatible structure, they are not allowed to be assigned as their types are not the same. The following example will provide a solution of this `dilemma':
\begin{lstlisting}[language=Oberon,frame=none,caption={Same Types}]
MODULE Test;
VAR
    x,y: RECORD a,b: INTEGER END;
BEGIN
    x := y; (* x and y are of the same type, thus assignment compatible *)
END Test;
\end{lstlisting}
Now, assume that variables \verb+x+ and \verb+y+ were declared in different scopes, then such a solution would not be possible any more and then type declarations are a must. In the following example, a type declaration is used instead of an immediate formulation in the variable declaration:
\begin{lstlisting}[language=Oberon,frame=none,caption={Using type declarations}]
MODULE Test;
TYPE
MyRecord = RECORD a,b: INTEGER END;

VAR
x: MyRecord;

PROCEDURE Print(m: MyRecord);
BEGIN
    KernelLog.Int(x,10); KernelLog.Int(y,10); KernelLog.Ln;
END Print;

BEGIN
    Print(x)
END Test;
\end{lstlisting}
Note that the call of procedure \verb+Print+ with variable \verb+x+ requires that \verb+x+ is assignment compatible to the respective parameter (which is the case, as \verb+x+ and \verb+m+ are of the same type).

Two types are of the same type, if they are provided by the same qualified identifier, or if one is an (immediate or indirect) alias of the other. Examples:
\begin{lstlisting}[language=Oberon,frame=none,caption={Same and different types}]
TYPE
Number=REAL; (* same type as REAL and Float *)
Float =REAL; (* same type as REAL and Number *)
MyRecord = RECORD a,b: INTEGER END;  (* same as MyAlias and AnotherAlias *)
AnotherRecord = RECORD a,b: INTEGER END; (* no same type available *)
MyAlias = MyRecord; (* same as MyRecord and AnotherAlias *)
AnotherAlias = MyAlias; (* same as MyAlias and MyRecord *)
\end{lstlisting}

We will introduce the basic and composite types in more details in sections \ref{section:BasicTypes} and \ref{section:CompositeTypes}

\subsubsection{Variable Declaration Section}\label{section:VariableDeclarationSection}
In Active Oberon, variables have to be declared before use in a variable declaration section. A variable declaration consists of an identifier and a type. Variables can be declared globally, in a procedure scope, in an object or in a record scope. 

\begin{lstlisting}[language=Oberon,frame=none,caption={Variables and Parameters}]
MODULE Variables;
TYPE
    (* variables in a record *)
    Pair=RECORD x,y: REAL END;
    PairPointer = POINTER TO Pair;

VAR (* global variables *)
    a: LONGINT;
    b: Pair;
    c: PairPointer;
    
END Variables;
\end{lstlisting}

\subsubsection{Procedure Declaration Section}\label{section:ProcedureDeclarationSection}
Procedures contain the executable code of a module. They can be declared in a modules scope, within procedure scopes (`nested procedures') or in object scopes. Procedures can be called in executable code and variables can be passed to them. Parameters are special variables that refer to expressions that have been passed to the procedure from its caller. Parameters are declared in the head of the procedure declaration.

Parameters can be {\em value parameters}, in which case they represent the actual value of an expression being passed to the respective procedure. Or parameters can be {\em variable parameters}, in which case they stand for the reference of a designator that has been passed to the procedure. The modification of a value parameter within a procedure does only have a temporary effect within the procedure while the modification of a variable parameter implies the modification of the passed variable.

\begin{lstlisting}[language=Oberon,frame=none,caption={Procedures}]
MODULE Procedures;

TYPE
    O = OBJECT

    PROCEDURE Method;
        PROCEDURE NestedProcedure;
        BEGIN
        END NestedProcedure;
    BEGIN
    END Method;

    END O;

    PROCEDURE GlobalProcedure;
        PROCEDURE NestedProcedure;
        BEGIN END NestedProcedure;
    END GlobalProcedure;

    PROCEDURE Square(x: REAL): REAL;
    BEGIN x := x*x; RETURN x
    END Square;

    PROCEDURE Inc(VAR i: INTEGER); 
    BEGIN i := i+1 
    END Inc;

    PROCEDURE Test*;
    VAR x,sq: REAL; i: INTEGER; 
    BEGIN
        x := 10; i := 0; 
        sq := x;
        Inc(i);  
    END Test;

END Procedures;
\end{lstlisting}

\subsection{Basic Types}\label{section:BasicTypes}
There are nine predeclared basic types in Active Oberon. Their names and valid values are shown in table \ref{table:BasicTypes}.

\begin{table}
\begin{tabular}{|l|l|l|}
\hline
Type name & Size & Valid values \\
\hline\hline
\verb+BOOLEAN+ & 1 byte & \verb+TRUE+ or \verb+FALSE+ \\
\hline
\verb+CHAR+ & 1 byte & characters of the extended ASCII set (\verb+0X+ \ldots \verb+0FFX+) \\
\hline
\verb+SHORTINT+ & 1 byte & integers between $-2^{7}$ and $2^{7}-1$ \\
\verb+INTEGER+ & 2 bytes & integers between $-2^{15}$ and $2^{15}-1$ \\
\verb+LONGINT+ & 4 bytes & integers between $-2^{31}$ and $2^{31}-1$ \\
\verb+HUGEINT+ & 8 bytes & integers between $-2^{63}$ and $2^{63}-1$ \\
\hline
\verb+REAL+ & 4 bytes & floating point value between $-3.4028^{38}$ and $+3.4028^{38}$ \\
\verb+LONGREAL+ & 8 bytes & floating point value between $-1.7976^{308}$ and $+1.7976^{308}$ \\
\hline
\verb+SET+ & 4 bytes & any set combination of the integer values between 0 and 31 \\
\hline
\end{tabular}
\caption{Predeclared basic types}\label{table:BasicTypes}
\end{table}

\subsubsection{The types SHORTINT, INTEGER, LONGINT and HUGEINT}\label{section:IntegerTypes}
These four types comprise the {\em integer types}. They represent the integer numbers and differ by the cardinality of the set of random numbers represented by each type. The need for different types arises from the architecture of machines which - for reasons of efficiency - provide various word formats with corresponding machine instructions.

\subsubsection{The types REAL and LONGREAL} \label{section:RealTypes}
The real types approximate the real numbers. Each element from the set of REAL or LONGREAL is a representative of an interval of genuine real numbers. Variables of a real type are represented by pairs of integers, a {\em mantissa} and an {\em exponent}. This is called {\em floating-point} representation. The two types are distinguished by the number of digits of the mantissa (fractional part) and the exponent. As with the integer types, {\em overflow} may occur and result in termination of the program.

Floating point numbers are only an approximation to the real numbers of mathematics. As a consequence computations involving floating-point values are inexact because each operation may be subject to truncation. The resulting problems are well investigated and treated in every text on numerical mathematics.

\subsubsection{Hierarchy of the numeric types} \label{section:HierarchyNumericTypes}
The {\em numeric types} are comprised of the integer and real types and form a set hierarchy

$LONGREAL \supseteq REAL \supseteq HUGEINT \supseteq LONGINT \supseteq INTEGER \supseteq SHORTINT$

The range of the larger type includes the ranges of the smaller types. For example, REAL {\em includes} HUGEINT \ldots SHORTINT. The smaller type is said to be {\em compatible} with the larger one in the sense that it can without danger of loss of leading digits be converted. In most cases, such a conversion is also exact. In assignments and in expansions the conversion of internal representations is automatic.

\subsubsection{The type BOOLEAN} \label{section:BooleanType}
A Boolean value is one of the {\em logical truth values} which are represented in Active Oberon by the standard identifiers TRUE and FALSE.

\subsubsection{The type SET} \label{section:SetType}
The values which belong to the type SET are {\em elements of the power set of} $[0, 1, \ldots, N]$ where $N$ is equal to MAX(SET). $N$ is a constant defined by the implementation. It is typically the word length of the computer (or a small multiple of it). In fact, sets are efficiently implemented as bit operations.

Examples of set constants are:
\begin{lstlisting}[language=Oberon,frame=none]
{}, {1, 6, 10}, {0, 2..4, 8}
\end{lstlisting}

where \verb+{}+ denotes the empty set and the subset \verb+2..4+ refers to the elements 2, 3 and 4.

\subsubsection{The type CHAR}
A major portion of the input and output of computers is in the form of character strings that contain values of type CHAR. The value range of the type CHAR consists of the characters of the roman alphabet and a small set of special symbols used frequently in commerce and mathematics.

The set representing the type CHAR is ordered and each character has a fixed position or {\em ordinal number}. This is reflected in the notation for character constants which may be written as "a" or 61X for the letter a. The first representation denotes the value of the variable of type CHAR, the second its (hexadecimal) {\em ordinal} number.

\subsection{Composite Types}\label{section:CompositeTypes}

In Active Oberon, there are three composite types available. Arrays, Records and Pointers.

\subsubsection{Arrays}
Arrays can be declared static, open or dynamic. Static arrays are declared as ARRAY number OF BaseType, where number must be constant. The BaseType can be an array, which allows expressions like ARRAY 12 OF ARRAY 13 OF ARRAY 11 OF REAL. Arrays can be declared open only in a parameter section. Open arrays are declared as ARRAY OF ...  Dynamic arrays are basically references pointing to an array with lengths that may be provided during runtime. They are declared as POINTER TO ARRAY OF ...
\begin{lstlisting}[language=Oberon,frame=none]
VAR
a: ARRAY 32 OF ARRAY 20 OF INTEGER; (* static *)
b: POINTER TO ARRAY OF ARRAY OF REAL; (* dynamic *)

PROCEDURE Print(x: ARRAY OF CHAR); (* open *)
END Print;
\end{lstlisting}

\subsubsection{Records}
Records are containers of data. Records are value types and are declared as RECORD (variables) END. Records can also be declared as reference types using POINTER TO. Record data are referred to via recordName.variableName.
\begin{lstlisting}[language=Oberon,frame=none]
VAR
a: RECORD x,y: LONGINT END;
p: POINTER TO RECORD a,b: REAL END;
...
BEGIN
...
NEW(p);
p.x := a.x;
....
\end{lstlisting}

\subsubsection{Objects}
Objects are basically reference records that can additionally be equipped with procedures. Procedures in an object are methods: they reside in the object scope and have access to the object's variables. An object is a reference type and can be explicitly referred to in its method using the SELF identifier.
A method tagged with an ampersand character is an \emph{object initializer}. This method is automatically called when an instance of the object is created and processed before the object becomes publicly available. An object may have at most one initializer. If absent, the initializer of the base type is inherited. Initializers can be called like methods.

\begin{lstlisting}[language=Oberon,frame=none]
TYPE
MyObject = OBJECT (* class *)
VAR x,y: REAL;

PROCEDURE Equals(o: MyObject): BOOLEAN;
BEGIN
    IF o = SELF THEN RETURN TRUE
    ELSE RETURN (o.x = x) & (o.y = y)
    END;
END Equals;

PROCEDURE &Init(x, y : REAL); (* initializer *)
BEGIN
    SELF.x := x; SELF.y := y;
END Init;

END MyObject;

VAR p,q: MyObject; (* objects / instances *)
...

BEGIN
    NEW(p, 1.0, 9.99); (* instantiate object p with x and y parameters for initializer *)
    ...
    IF p.Equals(q) THEN ...
    END;
\end{lstlisting}

\subsubsection{Inheritance}
Active Oberon is an object oriented language. For both, records and objects, inheritance is supported by Oberon. It is possible to extend records and objects and to use type checks, type guards and overloading of methods.
Record and object extension is declared as in the following example:

\begin{lstlisting}[language=Oberon,frame=none]
TYPE

Rectangle = RECORD
    x,y,w,h: INTEGER
END

FilledRectangle= RECORD(Rectangle)
    color: INTEGER
END;

Window = OBJECT
VAR x,y,w,h: INTEGER;

    PROCEDURE Print;
    BEGIN
        (* draw frame *)
    END Print;
END Window;

FilledWindow = OBJECT (Window)
VAR color: INTEGER;

    PROCEDURE Print; (* overwrites Window.Print *)
    BEGIN
        Print^; (* supercall *)
        (* fill *)
    END Print;
END FilledWindow;

\end{lstlisting}

\subsection{Concurrency Support}
Active Oberon provides built-in concurrency support. Threads are represented as active objects and language constructs for ensuring mutual exclusion and thread synchronization are provided.

\subsubsection{Active Objects}
The declaration of an object type may include an \emph{object body}. The body is the object's activity, to be executed whenever an object instance is allocated after the initializer (if any) completed execution. The object body is annotated with the \emph{ACTIVE} modifier. At allocation, a new process is allocated to execute the body concurrently.
If the ACTIVE modifier is not present, the body is executed synchronously, i.e. NEW returns only after the body has terminated execution.
The active object activity terminates whenever the body execution terminates. As long as the body executes, the object is kept alive (i.e. cannot be garbage collected). After that, the object becomes a passive one, and will be collected according to the usual rules.

\begin{lstlisting}[language=Oberon,frame=none]
TYPE
   ActiveObject = OBJECT
   BEGIN {ACTIVE}
       (* do some useful work *)
   END ActiveObject;

VAR
   o : ActiveObject

BEGIN
   NEW(o); (* instantiate object o and create new process that executes the object body *)
\end{lstlisting}

\subsubsection{Protection}
A Statement Block is a sequence of statements delimited by BEGIN and END. It can be used anywhere like a simple statement. It is most useful when used with the EXCLUSIVE modifier to create a critical region to protect the statements against concurrent execution. Our protection model is an instance-based monitor.
Every object instance is protected and the protection granularity is any statement block inside the object’s method, ranging from a single statement to a whole method.
A statement block can be protected against concurrent access by annotating it with the modifier EXCLUSIVE. Upon entering an exclusive block, an activity is preempted as long as another activity stands in an exclusive block
of the same object instance. An activity cannot take an object’s lock more than once, re-entrance is not allowed.
Every module is considered to be an object type with a singleton instance, thus its procedures can also be protected. The scope of protection is the whole module, like in a monitor.

\begin{lstlisting}[language=Oberon,frame=none]
MODULE Demo;

TYPE
    SomeObject = OBJECT

        PROCEDURE O1;
        BEGIN {EXCLUSIVE}
            (* critical section o1 *)
        END O1;

        PROCEDURE O2;
        BEGIN
            (* non-critical section *)
            BEGIN {EXCLUSIVE} (* critical section o2 *) END;
            (* non-critical section *)
        END O2;

    END SomeObject;

PROCEDURE P1;
BEGIN {EXCLUSIVE}
    (* critical section p1 *)
END P1;

PROCEDURE P2;
BEGIN
    (* non-critical section *)
    BEGIN {EXCLUSIVE} (* critical section p2 *) END;
    (* non-critical section *)
END P2;

END Demo.
\end{lstlisting}

In this example, at most one thread can be in the critical section \emph{p1} and \emph{p2} at any time. For each instance of SomeObject, at most one thread can be in \emph{o1} or \emph{o2} at any time. Note that there is no relation of \emph{p1}, \emph{p2} and \emph{o1}, \emph{o2} in different object instances since the protection is based on \emph{instance-based} monitors.

\subsubsection{Synchronization}
The built-in procedure AWAIT is used to synchronize an activity with a state of the system. AWAIT can take any boolean condition. The activity is allowed to continue execution only when condition is true. While the condition is not established, the activity remains suspended. If inside a protected block, the lock on the protected object is released, as long as the activity remains suspended
(to allow other activities to change the state of the object and thus establish the condition). The activity is restarted only if the lock can be taken. The system is responsible for evaluating the conditions and for resuming suspended activities. The conditions inside an object instance are re-evaluated whenever some activity leaves a protected block inside the same object instance.
This implies that changing the state of an object outside a protected block won’t have the conditions re-evaluated.
When several activities compete for the same object lock, the activities whose conditions are true are scheduled before those that only want to enter a protected region.

\begin{lstlisting}[language=Oberon,frame=none]
TYPE
    Synchronizer = OBJECT
    VAR awake : BOOLEAN;

        PROCEDURE Wait;
        BEGIN {EXCLUSIVE}
           AWAIT(awake); (* suspend caller until awake = TRUE *)
           awake := FALSE;
        END Wait;

        PROCEDURE Wakeup;
        BEGIN {EXCLUSIVE}
           awake := TRUE;
        END Wakeup;

    END Synchronizer
\end{lstlisting}

\subsubsection{Examples}
The following example shows the implementation of a bounded-buffer.

\begin{lstlisting}[language=Oberon,frame=none]
TYPE
  Item* = OBJECT END Item;

  Buffer* = OBJECT
  VAR head, num: LONGINT; buffer: POINTER TO ARRAY OF Item;

    PROCEDURE Append*(x: Item);
    BEGIN {EXCLUSIVE}
      AWAIT(num # LEN(buffer));
      buffer[(head+num) MOD LEN(buffer)] := x;
      INC(num)
    END Append;

    PROCEDURE Remove*(): Item;
    VAR x: Item;
    BEGIN {EXCLUSIVE}
      AWAIT(num # 0);
      x := buffer[head];
      head := (head+1) MOD LEN(buffer);
      DEC(num);
      RETURN x
    END Remove;

    PROCEDURE &Init*(n: LONGINT);
    BEGIN
      head := 0; num := 0; NEW(buffer, n)
    END Init;
  END Buffer;
\end{lstlisting}

\section{Application Programming Interface}

\subsection{In- and Output}
This section gives a brief overview of the most often used I/O facilities.

\subsubsection{Streams}
Streams provide an abstraction for easily accessing various resources that can be accessed byte-wise. Streams can be opened on files, network connections, serial port connection, memory and many other resources. Streams are always buffered and therefore have to be flushed explicitly by the programmer.
Streams are unidirectional, i.e. either read from a resource (\emph{Readers}) or write to a resource (\emph{Writers}). Note that streams maintain a stream position that is adapted automatically whenever a read or write is performed. Stream may support setting the position explicitly, depending on the underlying resource.


\begin{center}
    \begin{table}
    \begin{tabular}{|l|l|}
    \hline
    Method & Description \\
    \hline
    CanSetPos() : BOOLEAN & Returns TRUE if the stream supports random access, FALSE otherwise \\
    SetPos(pos : LONGINT) & Set current position to "pos" \\
    Pos() : LONGINT & Get current position \\
    \hline
    Available() : LONGINT & Returns bytes currently available in the input buffer \\
    \hline
    Char(VAR x : CHAR) & Read one byte \\
    Get() : CHAR & Like Char but return result \\
    Peek() : CHAR & Like Get but leave byte in the input buffer \\
    Bytes(VAR x : ARRAY OF CHAR; ofs, size : LONGINT; VAR len : LONGINT) & Read "size" bytes into x, starting at offset "ofs" \\
    SkipBytes(n : LONGINT) & Skip "n" bytes on the reader \\
    \hline
    \end{tabular}
    \caption{Basic Reader Interface}
    \end{table}
\end{center}

\begin{center}
    \begin{table}
    \begin{tabular}{|l|l|}
    \hline
    Method & Description \\
    \hline
    CanSetPos() : BOOLEAN & Returns TRUE if the stream supports random access, FALSE otherwise \\
    SetPos(pos : LONGINT) & Set current position to "pos" \\
    Pos() : LONGINT & Get current position \\
    \hline
    Update() : LONGINT & Write bytes in output buffer to resource \\
    \hline
    Char(x : CHAR) & Write one byte \\
    Bytes(CONST x : ARRAY OF CHAR; ofs, size : LONGINT) & Write "size" bytes into x, starting at offset
    "ofs" \\
    SkipBytes(n : LONGINT) & Skip "n" bytes on the reader \\
    \hline
    \end{tabular}
    \caption{Basic Writer Interface}
    \end{table}
\end{center}

\begin{center}
    \begin{table}
    \begin{tabular}{|l|l|}
    \hline
    Method & Description \\
    \hline
    Int(VAR x : LONGINT; hex : BOOLEAN) & Read a decimal or hexdecimal number from stream \\
    EOLN() : BOOLEAN & Return TRUE if at the end of a line (or file) \\
    Ln(VAR x : ARRAY OF CHAR) & Read all characters until the end of the line (inclusive) \\
    SkipLn() & Skip over all characters until the end of the line (inclusive) \\
    SkipSpaces() & Skip over space and TAB characters \\
    SkipWhitespace() & Skip over space, TAB and EOLN characters \\
    Token(VAR token : ARRAY OF CHAR) & Read a token, consisting of any string characters terminated by space, TAB or EOLN \\
    String(VAR string : ARRAY OF CHAR) & Read an optionally "" or '' enquoted string \\
    \hline
    GetString(VAR string : ARRAY OF CHAR) & Equivalent to SkipWhitespace; String(string) \\
    GetInteger(VAR integer : LONGINT; hex : BOOLEAN) & Equivalent to SkipWhitespace; Int(integer, hex) \\
    GetChar(VAR ch : CHAR) & Equivalent to SkipWhitespace; Char(ch) \\
    \hline
    \end{tabular}
    \caption{Extended Reader Interface}
    \end{table}
\end{center}

\begin{center}
    \begin{table}
    \begin{tabular}{|l|l|}
    \hline
    Method & Description \\
    \hline
    Ln() & Write an ASCII end-of-line <CR><LF> \\
    String(CONST string : ARRAY OF CHAR) & Write an 0X-terminated string (excluding 0X) \\
    Int(x, w : LONGINT) & Write an integer in decimal right-justified in a field of at least w characters \\
    Hex(x : HUGEINT; w : LONGINT) & Wirte an integer in hexadecimal right-justified in a field of at least w characters \\
    \hline
    \end{tabular}
    \caption{Extended Writer Interface}
    \end{table}
\end{center}

\subsubsection{Commands}
As has already been indicated in Section \ref{section:ModulesAndCommands}, a procedure can act as a command if and only if it is exported and it provides no return parameter and it provides at most one input parameter of type \verb+Commands.Context+ and it is declared in the immediate module scope.

The following example module contains examples of procedures that can or cannot act as commands. 
\begin{lstlisting}[language=Oberon,frame=none,caption=Procedures and Commands]
MODULE Sample;

IMPORT Commands, KernelLog;

    (* Simple is a command, "*" indicates that Simple is exported *)
    PROCEDURE Simple*;
    BEGIN KernelLog.String("SimpleOutput called"); KernelLog.Ln;
    END Simple;

    (* Internal is not a command: it is not marked exported *)
    PROCEDURE Internal;
    BEGIN KernelLog.String("InternalOutput called"); KernelLog.Ln;
    END Internal;

    (* WithContext is a valid command *)
    PROCEDURE WithContext*(context: Commands.Context);
    BEGIN
        context.out.String("this is written to the standard output stream");
        context.out.Ln;
    END WithContext;

    (* WithOther is not a command: parameter type is not Commands.Context *)
    PROCEDURE WithOther*(VAR x: REAL);
    BEGIN x := 2*x
    END WithOther

    (* WithReturn is not a command as it provides a return value *)
    PROCEDURE WithReturn*(): LONGINT;
    BEGIN RETURN 10
    END WithReturn;

END Sample.
\end{lstlisting}

After compilation of the module \verb+Sample+, the commands \verb+Sample.Simple+ and \verb+Sample.WithContext+ can be activated. The attempt to activate \verb+Sample.Internal+, \verb+Sample.WithOther+ or \verb+Sample.WithReturn+ will fail with a short error message on the kernel log.

As we have seen in ..., there are two kinds of commands

\begin{lstlisting}[language=Oberon,frame=none]
PROCEDURE ProcedureName* BEGIN END ProcedureName;
PROCEDURE ProcedureName*(context : Commands.Context); BEGIN END ProcedureName; \end{lstlisting}

\begin{lstlisting}[language=Oberon,frame=none]
TYPE
    Context* = OBJECT
    VAR
        in-, arg- : Streams.Reader;
        out-, error- : Streams.Writer;
        caller- : OBJECT;
    END Context;
\end{lstlisting}

Command line arguments can be accessed using the \emph{arg} stream. in \emph{is} the command input stream. For output, the streams \emph{out} and \emph{error} are used.
The caller field optionally contains a reference to an object that is responsible for the command invocation.

As a simple in- and output example,...

\begin{lstlisting}
PROCEDURE Add*(context : Commands.Context)
VAR a, b : LONGINT;
BEGIN
    context.arg.GetInteger(a, FALSE);
    context.arg.GetInteger(b, FALSE);
    context.out.Int(a, 0); context.out.String(" + "); context.out.Int(b, 0);
    context.out.String(" = "); context.out.Int(a + b, 0);
    context.out.Ln;
END Add;
\end{lstlisting}

Note that both output stream buffer (out and error) are flushed automatically by the command interpreter after the PROCEDURE Add returns.

\subsubsection{Files}
The module Files is the interface implemented by file system drivers and the same time the \AZ Files API.

The most useful operations are

Files.Old(filename : ARRAY OF CHAR) : File;
Files.New(filename : ARRAY OF CHAR) : File;
Files.Register(file);

The actual access to files can be achieved using either the low-level File object or by opening Streams on the file.

\paragraph{File Interface}
The low-level file interface uses so-called riders as context for accessing files. Multiple riders can be positioned independently on a given file. Essentially, riders are used for tracking the position in a file and store the result of the last operation on the file. As when using streams, read and write operations automatically update the current position.

File.Set(VAR r : Rider; position : LONGINT)
File.Pos(VAR r : Rider) : LONGINT;

File.Read(VAR r : Rider; VAR x : Char);
File.ReadBytes(VAR r : Rider; x : ARRAY OF CHAR; offset, length : LONGINT);

File.Write(VAR r : Rider; x : CHAR);
File.WriteBytes(VAR r : Rider; CONST x : ARRAY OF CHAR; offset, length : LONGINT);

File.Update;

\paragraph{Using Streams On Files}

Files.OpenReader(VAR r: Files.Reader; f : File; position : LONGINT);
Files.OpenWriter(VAR w : Files.Writer; f : File; position : LONGINT);

\begin{lstlisting}
PROCEDURE CreateFile*(context : Commands.Context);
VAR file : Files.File; filename : Files.FileName; writer : Files.Writer; ch : CHAR;
BEGIN
   context.arg.GetString(filename);
   file := Files.New(filename);
   IF (file # NIL) THEN
      Files.Register(file);
      Files.OpenWriter(writer, file, 0);
      context.arg.Char(ch);
      WHILE (context.arg.res = Streams.Ok) DO
         writer.Char(ch);
         context.arg.Char(ch);
      END;
   END; END CreateFile;
\end{lstlisting}

In this example, executing CreateFile HelloWorld.txt Hello world ~ creates a new file (or overwrites an existing one) with the content "Hello World".

\subsubsection{String Manipulation}
The module Utilities provides procedures for string manipulation.


\appendix
\section{Appendix}

\subsection{The module System}
The module SYSTEM contains definitions that are necessary to program low-level operations referring directly to resources particular to a given computer and/or implementation. These include, for example, facilities for accessing devices that are controlled by the computer, and facilities to override the data type compatibility rules otherwise imposed by the language definition. The functions and procedures exported by this module expose the complete memory, and allow unsafe type-casts to be made. They should be used with care, because if misused they can easily crash the whole system. It is a bit like programming in C. It is recommended to restrict their use to specific low-level modules. Such modules are inherently non-portable, but easily recognized due to the identifier SYSTEM appearing in their import list.
The subsequent definitions are applicable to the \AZ operating system for which SYSTEM is implemented directly in the compiler.

\begin{center}
    \begin{table}
    \begin{tabular}{|l|l|}
    \hline
    Function & Description \\
    \hline
    BIT(adr : ADDRESS; n : LONGINT) : BOOLEAN & Returns TRUE if bit n at adr is set, FALSE otherwise \\
    LSH(x : IntValue; n : LONGINT) : IntValue & Returns value x logically shifted left n bits (shifts right for n < 0) \\
    ROT(x : IntValue; n : LONGINT) : IntValue & Returns value x rotated left by  n bits (rotates right for n < 0) \\
    \hline
    \end{tabular}
    \caption{BIT Manipulation}
    \end{table}
\end{center}

\begin{center}
    \begin{table}
    \begin{tabular}{|l|l|}
    \hline
    Type & Description \\
    \hline
    ADDRESS & Representation of memory addresses. Currently, this is an alias to either LONGINT or HUGEINT \\
    SIZE & \\
    \hline
    BYTE & \\
    \hline
    \end{tabular}
    \caption{SYSTEM Types}
    \end{table}
\end{center}

\begin{center}
    \begin{table}
    \begin{tabular}{|l|l|}
    \hline
    ADR(VAR v : ANY) : ADDRESS & Returns the address of v \\
    \hline
    SIZEOF(v : ANY) : SIZE & Returns the size of type v \\
    \hline
    VAL(T : AlmostAnyType; x : ANY) : Type & Unsafe type cast. Returns x interpreted as type T with no conversion \\
    \hline
    \end{tabular}
    \caption{Addresses, Sizes and Unsafe Typecasts}
    \end{table}
\end{center}
\begin{center}
    \begin{table}
    \begin{tabular}{|l|l|}
        \hline
        Name & Function \\
        \hline
        PUT(adr : ADDRESS; x : Type) & Mem[adr] := x whereas the size of type x is 8, 16, 32 or 64 bits \\
        \hline
        PUT8(adr: ADDRESS; x: SHORTINT) & Mem[adr] := x \\
        PUT16(adr: ADRESS; x: INTEGER) & \\
        PUT32(adr: ADDRESS; x: LONGINT) & \\
        PUT64(adr: ADDRESS; x: HUGEINT) & \\
        \hline
        GET(adr : ADDRESS; VAR x : Type) & x := Mem[adr] whereas the size of type x is 8, 16, 32 or 64 bits \\
        \hline
        GET8(adr: ADDRESS): SHORTINT & RETURN Mem[adr] \\
        GET16(adr: ADDRESS): INTEGER & \\
        GET32(adr: ADDRESS): LONGINT & \\
        GET64(adr: ADDRESS): HUGEINT & \\
        \hline
        MOVE(src, dst : ADDRESS; n : SIZE) & Copy "n" bytes from address "src" to address "dst" \\
        \hline \end{tabular}
    \caption{Direct Memory Access Functions}
    \end{table}
\end{center}

\begin{center}
    \begin{table}
    \begin{tabular}{|l|l|} \hline
    PORTIN(adr : LONGINT; VAR x : Type) & Perform a port input instruction at the specified I/O address. The size of type x must be 8, 16 or 32 bits \\
    PORTOUT(adr : LONGINT; x : Type) & Perform a port output instruction at the specified I/O address. The size of type x must be 8, 16 or 32 bits \\
    \hline
    CLI() & Disable interrupts on the current processor \\
    STI() & Enable interrupts on the current processor \\
    \hline
    GETREG(reg : LONGINT; VAR x : Type) & x := REGISTER(reg) where the size of type x is 8, 16, 32 or 64 bits depending on the register \\
    PUTREG(reg : LONGINT; x : Type) & REGISTER(reg) := x; where SIZEOF(x) is 8, 16, 32 or 64 bits \\
    \hline
    EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI & 32 bit registers \\
    AX, CX, DX, BX, SP, BP, SI, DI & 16 bit registers \\
    AL, CL, DL, BL, AH, CH, DH, BH & 8 bit registers \\
    \hline
    \end{tabular}
    \caption{IA-32 Specific Functions}
    \end{table}
\end{center}

\subsection{Active Oberon EBNF}

\end{document}