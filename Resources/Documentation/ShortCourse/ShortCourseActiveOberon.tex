\documentclass[a4paper,11pt]{article}
\usepackage{color,bbm}
\usepackage{longtable}
\usepackage{amssymb,amsmath,graphicx}
\usepackage{nonfloat}
\usepackage{colortbl}
\usepackage{fancybox}
\usepackage{hyperref}
\usepackage{listings}

% --------------------------------- page layout --------------------------------------
\pagestyle{headings}
% other font styles:
%\usepackage[math]{iwona} % iwona, kurier
%\usepackage{cmbright}

\oddsidemargin -0 cm
\evensidemargin 0 cm
%\topmargin -1.5cm
\textwidth 16   cm
%\textheight 25 cm

\parskip 5pt
\parindent 0cm

\definecolor{lightgrey}{rgb}{0.5,0.5,0.5}
\definecolor{darkgrey}{rgb}{0.4,0.4,0.4}

% --------------------------------- listings --------------------------------------


\newcommand{\changefont}[3]{\fontfamily{#1}\fontseries{#2}\fontshape{#3}\selectfont}

\newcommand{\progfont}{\changefont{pcr}{m}{n}}
\newcommand{\kwfont}{\changefont{pcr}{b}{n}}
\renewcommand{\lstlistingname}{Fig.}
\newcommand{\todo}[1]
            {\setlength{\fboxrule}{2pt}\fcolorbox{red}{yellow}{\begin{minipage}{\textwidth} \color{blue}$todo:$ #1 \end{minipage}}}

\newcommand{\pc}[1]{\makebox{\progfont #1}}
\newcommand{\kw}[1]{\makebox{\kwfont #1}}

\lstdefinelanguage{ebnf}[]{}
{morekeywords={},
sensitive=true,
comment=[l]{//},
comment=[s]{(*}{*)},
morestring=[b]',
morestring=[b]",
}
\lstdefinelanguage{Oberon}[]{Pascal}%
  {morekeywords={len,module,import},%
   sensitive=f,%
    morecomment=[s][\color{red}]{(*!}{!*)}
  }[keywords]%
\lstset{language=Oberon,
basicstyle=\scriptsize\progfont,keywordstyle=\kwfont ,identifierstyle=\progfont,
commentstyle=\color{darkgrey}, stringstyle=, showstringspaces=false, %keepspaces=true,
numbers=none, numberstyle=\tiny, stepnumber=1, numbersep=5pt, captionpos=b,
columns=flexible % flexible, fixed, fullflexible
framerule=1mm,frame=shadowbox, rulesepcolor=\color{blue}, % frame = shadowbox
xleftmargin=2mm,xrightmargin=2mm,
}
\renewcommand{\lstlistingname}{Fig.}

\begin{document}
\title{Programming in Active Oberon / A2 \\[1em] \normalsize A Short Introduction}
\author{Sven Stauber, Florian Negele, Ulrike Glavitsch, Felix Friedrich}
\maketitle

\tableofcontents
% --------------------------------------------------------------------------------
\subsection*{Objective}
This is a small introduction to the programming language Oberon and the operating / runtime system A2. This introduction does not replace a language report, neither is it an introduction to programming. It rather should provide a fast access to the used operating system and programming language by ways of comments and examples. It has been prepared for the Operating System Course, Spring Semester 2009 at ETH Zurich as accompanying material for the practial exercises.

\section{The Operating System A2 and the Language Active Oberon}
\subsection{A2 and Active Oberon}
A2 is a modern, multi-threaded operating system in the tradition of the ETH operating systems Medos, Oberon and Aos. It is completely written in Active Oberon with only very few exceptions: little parts of the kernel and some low-level optimized routines are implemented in in-line assembler. A2 does not use heavyweight processes but is rather composed of light-weight processes (`threads') that are supported by {\em Active Objects} in the language Active Oberon. Active Oberon is a highly readable, abstract programming language. Its abstraction protects programmers from artificial technical complexities while system-near programming is still possible by ways of a special `system' module. The interplay of an abstract language and efficient runtime accounts for the special flavour of A2.

\subsection{Modules and Commands}
Oberon is a modular programming language that is supported by a dynamic loading concept in the operating system A2. The role of programs and applications is played by {\em modules}. Instead of loading and executing a `program', {\em modules} are loaded and {\em commands} are executed. Once a module is loaded, it stays loaded until it is explicitly unloaded or until the system goes down. Before we give more details on modules and commands, we show an example of a very simple Oberon module:

\begin{lstlisting}[language=Oberon,frame=none,caption=A simple Oberon Module]
    MODULE Hello;

    IMPORT Commands;

        PROCEDURE World*(context: Commands.Context);
        BEGIN
            context.out.String("Hello World");
            context.out.Ln
        END World;

    END Hello.
\end{lstlisting}

Commands are executed by activating a command string of the form \verb+ModuleName.CommandName+ within any text displayed on the screen. In the simple example above, this would be \verb+Hello.World+. A command is usually activated by a middle-mouse click or by selecting the command string and using the key-combination \verb|Ctrl+Return|. When a command is activated, the module with name \verb+ModuleName+ is dynamically loaded on demand and the program counter (potentially of a newly created process) is set to the loaded procedure named \verb+CommandName+ in module \verb+ModuleName+.

Note that a module name has nothing to do with the name of the file that contains the source code of the module. It is pure convention that source code files are denominated as \verb+ModuleName.Mod+.

An Active Oberon module consists of {\em constants}, {\em variables}, {\em types} and {\em procedures}. Procedures contain executable code. A procedure may or may not accept parameters and a procedure may or may not return a parameter. A procedure can act as a command if and only if
\begin{itemize}
\item it is exported and
\item it provides no return parameter and
\item it provides at most one input parameter of type \verb+Commands.Context+
\item it is declared immediately in the module scope
\end{itemize}

The following example module contains examples of procedures that can or cannot act as commands. Note that comments in Oberon are embraced by \verb+(*+ and \verb+*)+.
\begin{lstlisting}[language=Oberon,frame=none,caption=Procedures and Commands]
    MODULE Sample;

    IMPORT Commands, KernelLog;

        (* Simple is a command, "*" indicates that Simple is exported *)
        PROCEDURE Simple*;
        BEGIN KernelLog.String("SimpleOutput called"); KernelLog.Ln;
        END Simple;

        (* Internal is not a command: it is not marked exported *)
        PROCEDURE Internal;
        BEGIN KernelLog.String("InternalOutput called"); KernelLog.Ln;
        END Internal;

        (* WithContext is a valid command *)
        PROCEDURE WithContext*(context: Commands.Context);
        BEGIN
            context.out.String("this is written to the standard output stream");
            context.out.Ln;
        END WithContext;

        (* WithOther is not a command as the type of its parameter is not Commands.Context *)
        PROCEDURE WithOther*(VAR x: REAL);
        BEGIN x := 2*x
        END WithOther

        (* WithReturn is not a command as it provides a return value *)
        PROCEDURE WithReturn*(): LONGINT;
        BEGIN RETURN 10
        END WithReturn;

    END Sample.
\end{lstlisting}

After compilation of the module \verb+Sample+, the commands \verb+Sample.Simple+ and \verb+Sample.WithContext+ can be activated. The attempt to activate \verb+Sample.Internal+, \verb+Sample.WithOther+ or \verb+Sample.WithReturn+ will fail with a short error message on the kernel log.

\subsection{Loading and Unloading Modules}
When a module is compiled, an {\em object file} is generated and is made persistent in a file. It is not immediately loaded.
Basically, a module \verb+M+ is loaded when a command of the form \verb+M.CommandName+ is activated.\footnote{The loading of a module M takes place independent of the string M.C being a valid command or not.} Additionally, modules are automatically loaded by the system when a module is loaded that imports them (cf.~ Paragraph \ref{Imports}).

Once a module \verb+A+ has been loaded, any call of a valid command \verb+A.C+ will execute the loaded code and will not result in re-loading \verb+A+. The reason is clear: other modules may rely on information being provided globally in module \verb+A+ or \verb+A+ may contain state information that should not be removed after one call. Consider the following example:

\begin{lstlisting}[language=Oberon,frame=none,caption=A simple Oberon Module]
    MODULE Hello;

    IMPORT KernelLog;

        PROCEDURE World*;
        BEGIN KernelLog.String("Hello World"); KernelLog.Ln;
        END World;

    BEGIN
        (* this is a special `procedure': the module body
          it is executed once a module has been freshly loaded *)
        KernelLog.String("Hello has been loaded"); KernelLog.Ln;
    END Hello.
\end{lstlisting}

The module body will be executed once after the module has been loaded but prior to any of its commands. Thus, a first call of \verb+Hello.World+ will result in the output \pc{Hello has been loaded} and \pc{Hello World} in the kernel log. Each subsequent call will result in an output of \pc{Hello World}, but no further execution of the body. Only if the module has been unloaded, the body is executed again. Note that, consequently, in order to see the effects of a modification and re-compilation of a module it has to be unloaded.

Modules can be unloaded explicitly with the command \verb+SystemTools.Unload ModuleNames ~+ where \verb+ModuleNames+ is a white space separated list of module names and `\verb+~+' indicates the end of the list. Note that a module \verb+A+ can only be unloaded if no other currently loaded module imports \verb+A+.


\section{Parts of an Active Oberon Module}
An Active Oberon Module consists of the following parts
\begin{itemize}
\item an import list,
\item a constant declarations section,
\item a type declarations section,
\item a variable declarations section and
\item a procedure declarations section.
\end{itemize}
Before we describe each of the sections in more detail, let us start with a little example module.

\begin{lstlisting}[language=Oberon,frame=none,caption={A useless module containing constants, types, variables and procedures}]
    MODULE Simple;

    (*-------------     import list       ------------*)
     IMPORT KernelLog, Commands, Streams;

    (*------------- constant declarations ------------*)
    CONST
        a*=100;
        s="a string";

    (*--------------  type declarations   ------------*)
    TYPE
        MyNumberType = LONGINT;
        MyRecordType* = POINTER TO RECORD a*,b,c: LONGINT END;

    (*------------- variable declarations ------------*)
    VAR
        globalObject: MyObjectType; x: INTEGER;

    (*------------- procedure declarations -----------*)
    PROCEDURE Modify(t: MyRecordType);
    BEGIN t.a := 10; t.b := 20; t.c := 30;
    END Modify;

    (* an exported procedure *)
    PROCEDURE Display*(stream: Streams.Stream; t: MyRecordType);
    BEGIN
        stream.Int(t.a,10);
        stream.Int(t.b,10);
        stream.Int(t.c,10);
    END Display;

    (* a valid command *)
    PROCEDURE Test*(context: Commands.Context);
    VAR t: MyRecordType;
    BEGIN Modify(t); Display(context.out,t);
    END Test;

    BEGIN (* the module body *)
        KernelLog.String("Simple Started"); KernelLog.Ln;
    END Simple.
\end{lstlisting}

\subsection{Imports and Exported Symbols} \label{subsection:Imports}
The exported symbols of a module can be made available to other modules. To make the symbols of module \verb+A+ available in module \verb+B+, module \verb+A+ has to be imported in module \verb+B+. A module import graph is a directed graph where cycles are forbidden. This is checked by the compiler.

Symbols in one module that are to be used in any other module must be exported. A symbol is exported by suffixing the name with an asterisk `\verb+*+'. It is exported read only by suffixing with a minus symbol `\verb+-+'. We provide a little example of a module \verb+A+ being imported by a module \verb+B+.

\begin{lstlisting}[language=Oberon,frame=none,caption={B imports A}]
MODULE A;
    CONST exportedConst*=100;
END A.

MODULE B;
    IMPORT A;
    VAR c: LONGINT;
BEGIN
    c := A.exportedConst;
END B.
\end{lstlisting}

\subsection{Constant Declarations}
Static values can be used directly in expressions as, for example, in \verb~a := 3+b~. To support better maintainable and readable code, it is possible to associate an identifier with a constant expression, in other words: to {\em declare a constant}. In Active Oberon, only values of basic type and strings can be declared as constant\footnote{There are exceptions: special mathematical arrays can also be declared as constants.}. The following module contains some examples.

\begin{lstlisting}[language=Oberon,frame=none,caption={Declaration and Usage of Constants}]
MODULE A;

    CONST
        (* ---------------------- global constants ----------------------- *)
        someInteger* = 800; (* exported *)
        anotherInteger= someInteger + 1; (* constant expression *)
        someReal = 4.44E-5;
        anotherReal* = 5.5; (* exported *)
        someString = "This is a string";
        max       = 2147483647;
        allbits   = 7FFFFFFFH; (* hex number *)
        step      = 7;

    VAR
        (* ----------------------- global variable ----------------------- *)
        Z: LONGINT;

        PROCEDURE Rand*(): LONGINT;
        (* constants can also be declared in procedure scope: *)
        CONST a = 16807; q = 127773; r = 2836;
        VAR t: LONGINT;
        BEGIN
            t := a * (Z MOD q) - r * (Z DIV q);
            IF t > 0 THEN Z := t ELSE Z := t + max END;
            RETURN Z;
        END Rand;
BEGIN
    Z := someInteger;
END A.
\end{lstlisting}

\subsection{Type Declarations}
Type declarations bind an identifier to a type. On the one hand, a type declaration can provide an alias to another type including built-in (basic) types, such as integer, real, character etc. On the other hand, a type declaration can provide a {\em binding of an identifier to a custom form of representation} (usually a composite type). However, type declarations go beyond a mere convenience: in Active Oberon two variables are not necessarily of the same type, if their representation coincide. Before we provide the syntax of type declaration, have a short glance at the following example:
\begin{lstlisting}[language=Oberon,frame=none,caption={Incompatible types}]
MODULE Test; 
VAR 
    x: RECORD a,b: INTEGER END; 
    y: RECORD a,b: INTEGER END; 
BEGIN 
    x := y; (* THIS WILL NOT COMPILE *) 
END Test; 
\end{lstlisting}
Although in the previous example the variables \verb+x+ and \verb+y+ are declared as types with a compatible structure, they are not allowed to be assigned as their types are not the same. The following example will provide a solution of this `dilemma': 
\begin{lstlisting}[language=Oberon,frame=none,caption={Same Types}]
MODULE Test;
VAR
    x,y: RECORD a,b: INTEGER END;
BEGIN
    x := y; (* x and y are of the same type, thus assignment compatible *)
END Test;
\end{lstlisting}
Now, assume that variables \verb+x+ and \verb+y+ were declared in different scopes, then such a solution would not be possible any more and then type declarations are a must. In the following example, a type declaration is used instead of an immediate formulation in the variable declaration:
\begin{lstlisting}[language=Oberon,frame=none,caption={Using type declarations}]
MODULE Test;
TYPE
    MyRecord = RECORD a,b: INTEGER END; 
VAR
    x: MyRecord; 
    
    PROCEDURE Print(m: MyRecord); 
    BEGIN
        KernelLog.Int(x,10); KernelLog.Int(y,10); KernelLog.Ln; 
    END Print; 
BEGIN
    Print(x)
END Test;
\end{lstlisting}
Note that the call of procedure \verb+Print+ with variable \verb+x+ requires that \verb+x+ is assignment compatible to the respective parameter (which is the case, as \verb+x+ and \verb+m+ are of the same type). 

Two types are of the same type, if they are provided by the same qualified identifier, or if one is an (immediate or indirect) alias of the other. Examples: 
\begin{lstlisting}[language=Oberon,frame=none,caption={Same and different types}]
TYPE 
    Number=REAL; (* type Number is of same type as REAL and Float *) 
    Float =REAL; (* type Float is of same type as REAL and Number *) 
    MyRecord = RECORD a,b: INTEGER END;  (* MyRecord is same as MyAlias and AnotherAlias *) 
    AnotherRecord = RECORD a,b: INTEGER END; (* There is no same type as AnotherRecord *) 
    MyAlias = MyRecord; (* MyAlias is same as MyRecord and AnotherAlias *) 
    AnotherAlias = MyAlias; (* AnotherAlias is same as MyAlias and MyRecord *)
\end{lstlisting}

We will introduce the basic and composite types in more details in sections \ref{section:BasicTypes} and \ref{section:CompositeTypes}

\subsection{Variable and Parameter Declarations}

\subsection{Procedure Declarations}

\section{Basic Types}\label{section:BasicTypes}

\section{Composite Types}\label{section:CompositeTypes}

\section{Active Objects}

\section{In- and Output}

\section{The module System}

\section{Active Oberon EBNF}



% --------------------------------------- examples -------------------------------
\newpage {\Huge EXAMPLES}
\section{Section}
\subsection{Subsection}
\subsubsection{SubSubSection}
\paragraph{Paragraph}

Example Listing EBNF
\begin{lstlisting}[language=ebnf]
Number       =  Integer | Real.
Integer      =  Digit {Digit} | Digit {HexDigit} 'H'.
Real         =  Digit {Digit} '.' {Digit} [ScaleFactor].
ScaleFactor  =  ('E' | 'D') ['+' | '-'] digit {digit}.
HexDigit     =  Digit | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'.
Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
\end{lstlisting}

Example Listing EBNF no frame
\begin{lstlisting}[language=ebnf,frame=none]
Number       =  Integer | Real.
Integer      =  Digit {Digit} | Digit {HexDigit} 'H'.
\end{lstlisting}


Example Listing Oberon
\begin{lstlisting}[language=Oberon]
    MODULE Test;
    PROCEDURE Test;
    VAR a,b,c: LONGINT;
    BEGIN
        a := b*b (* b is not initialized *)
    END Test;
    END Test.
\end{lstlisting}

Example Listing Oberon no frame with line numbers
\begin{lstlisting}[language=Oberon,frame=none,numbers=left]
    MODULE Test; (* module in upper case *)
    PROCEDURE Test;
    VAR a,b,c: LONGINT;
    BEGIN
        a := b*b
    END Test;
    END Test.
\end{lstlisting}

Example Listing Oberon NoFrame
\begin{lstlisting}[language=Oberon,frame=none]
    module Test; (* module in lower case *)
    procedure Test;
    var a,b,c: longint;
    begin
        a := b*b
    end Test;
    end Test.
\end{lstlisting}

Oberon keyword \kw{module} in text.

Oberon programming content \verb+a := b*b+ in text.

Math content $x \leftarrow 10$ in text.

Math content alone:
$$x \leftarrow 10$$




\end{document}

